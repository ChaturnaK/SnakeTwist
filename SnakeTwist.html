<!DOCTYPE html>
<html lang="en">

<head>
    <link rel="manifest" href="manifest.json">
    <meta name="theme-color" content="#38bdf8">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="#38bdf8">
    <link rel="apple-touch-icon" href="icon-192.png">
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Modern Snake Game (Tilt/D-Pad)</title>
    <style>
        body {
            background: linear-gradient(135deg, #e9e9f2 0%, #f6faff 100%);
            min-height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
            margin: 0;
        }

        .game-container {
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        #score-bar {
            font-family: 'Segoe UI', Arial, sans-serif;
            font-size: 1.3rem;
            font-weight: 600;
            color: #334155;
            margin-bottom: 10px;
            letter-spacing: 0.5px;
            background: #fff;
            padding: 8px 30px;
            border-radius: 22px;
            box-shadow: 0 2px 8px #93c5fd33;
            user-select: none;
        }

        #speed-bar-container {
            width: 410px;
            margin-bottom: 16px;
            margin-top: 2px;
            display: flex;
            flex-direction: column;
            align-items: center;
            font-family: 'Segoe UI', Arial, sans-serif;
        }

        #speed-bar-labels {
            width: 100%;
            display: flex;
            justify-content: space-between;
            font-size: 11px;
            color: #64748b;
            padding: 0 6px;
            box-sizing: border-box;
        }

        #speed-bar {
            width: 100%;
            height: 16px;
            background: #f3f4f6;
            border-radius: 8px;
            border: 2px solid #cbd5e1;
            box-shadow: 0 2px 8px #bae6fd66;
            position: relative;
            overflow: hidden;
            margin-bottom: 2px;
            margin-top: 3px;
        }

        #speed-bar-indicator {
            position: absolute;
            top: 0;
            bottom: 0;
            height: 100%;
            border-radius: 8px;
            transition: left 0.08s cubic-bezier(.4, 2, .7, 1), width 0.1s cubic-bezier(.4, 2, .7, 1), background 0.2s;
        }

        #pause-btn,
        #reset-dpad-btn {
            position: fixed;
            top: 16px;
            z-index: 201;
            background: #fff;
            border: 2px solid #38bdf8;
            color: #0ea5e9;
            border-radius: 12px;
            font-size: 1.3em;
            width: 52px;
            height: 52px;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            box-shadow: 0 2px 8px #38bdf833;
            transition: background 0.14s, box-shadow 0.14s;
            font-family: 'Segoe UI', Arial, sans-serif;
            margin-left: 8px;
        }

        #pause-btn {
            right: 22px;
        }

        #reset-dpad-btn {
            right: 82px;
        }

        #pause-btn:active,
        #reset-dpad-btn:active {
            background: #bae6fd;
        }

        #pause-btn[hidden],
        #reset-dpad-btn[hidden] {
            display: none;
        }

        #paused-overlay {
            position: fixed;
            left: 0;
            top: 0;
            width: 100vw;
            height: 100vh;
            background: rgba(0, 0, 0, 0.35);
            z-index: 2002;
            display: none;
            align-items: center;
            justify-content: center;
        }

        #paused-overlay-inner {
            background: #fff;
            padding: 40px 32px 34px 32px;
            border-radius: 24px;
            font-size: 2em;
            color: #0ea5e9;
            font-family: 'Segoe UI', Arial, sans-serif;
            box-shadow: 0 6px 36px #38bdf833;
            text-align: center;
            min-width: 220px;
            max-width: 80vw;
        }

        #tilt-sensitivity-container {
            margin: 10px 0 0 0;
            padding: 10px;
            border-radius: 8px;
            background: #f6faff;
            box-shadow: 0 2px 10px #bae6fd33;
            display: none;
            align-items: center;
            justify-content: center;
            gap: 12px;
        }

        #tilt-sensitivity-bar {
            width: 150px;
        }

        canvas {
            background: #f8fafc;
            border: 4px solid #38bdf8;
            border-radius: 22px;
            box-shadow: 0 8px 32px #38bdf866, 0 0 0 2px #bae6fd88;
            display: block;
            margin-top: 16px;
            touch-action: none;
            -webkit-user-select: none;
            user-select: none;
        }

        /* D-Pad Styles */
        #dpad-container {
            position: fixed;
            z-index: 210;
            display: none;
        }

        .dpad {
            width: 92px;
            height: 92px;
            background: rgba(56, 189, 248, 0.22);
            border-radius: 24px;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            box-shadow: 0 2px 16px #38bdf822;
            touch-action: none;
        }

        .dpad-row {
            display: flex;
            flex-direction: row;
            width: 100%;
            justify-content: center;
        }

        .dpad-btn {
            width: 44px;
            height: 44px;
            margin: 2px;
            border-radius: 14px;
            background: rgba(14, 165, 233, 0.65);
            color: #fff;
            font-size: 1.6em;
            border: none;
            display: flex;
            align-items: center;
            justify-content: center;
            box-shadow: 0 0 8px #bae6fd44;
            touch-action: none;
            transition: background 0.18s;
        }

        .dpad-btn:active {
            background: #38bdf8;
        }

        /* D-Pad Placement Overlay */
        #dpad-placement-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            background: rgba(0, 0, 0, 0.32);
            z-index: 3000;
            display: none;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            font-family: 'Segoe UI', Arial, sans-serif;
        }

        #dpad-placement-message {
            color: #38bdf8;
            font-size: 2em;
            font-weight: bold;
            background: #fff;
            padding: 36px 32px;
            border-radius: 24px;
            box-shadow: 0 4px 32px #38bdf822;
            opacity: 0.95;
        }

        /* Responsive for mobile */
        @media (max-width: 600px) {
            .game-container {
                gap: 10vw;
            }

            #score-bar {
                margin-bottom: 3vw;
            }

            #speed-bar-container {
                margin-bottom: 2vw;
            }

            canvas#gameCanvas {
                margin-top: 3vw;
            }

            #pause-btn,
            #reset-dpad-btn {
                width: 46px;
                height: 46px;
                font-size: 1.1em;
                top: 8px;
            }

            #pause-btn {
                right: 16px;
            }

            #reset-dpad-btn {
                right: 66px;
            }
        }
    </style>
</head>

<body>
    <button id="pause-btn" title="Pause/Resume" hidden>‚è∏Ô∏è</button>
    <button id="reset-dpad-btn" title="Reset D-Pad" hidden>üéØ</button>
    <div id="paused-overlay">
        <div id="paused-overlay-inner">
            <div style="font-size:1.5em;margin-bottom:16px;">‚è∏Ô∏è Game Paused</div>
            <button onclick="resumeGame()"
                style="font-size:1em;padding:10px 32px;border-radius:10px;background:#38bdf8;color:#fff;border:none;cursor:pointer;">Resume</button>
        </div>
    </div>
    <div id="dpad-placement-overlay">
        <div id="dpad-placement-message">Tap anywhere to place your D-pad</div>
    </div>
    <div id="dpad-container">
        <div class="dpad">
            <div class="dpad-row">
                <button class="dpad-btn" id="dpad-up" style="margin-bottom:-8px;">‚ñ≤</button>
            </div>
            <div class="dpad-row">
                <button class="dpad-btn" id="dpad-left" style="margin-right:-8px;">‚óÄ</button>
                <div style="width:10px;"></div>
                <button class="dpad-btn" id="dpad-right" style="margin-left:-8px;">‚ñ∂</button>
            </div>
            <div class="dpad-row">
                <button class="dpad-btn" id="dpad-down" style="margin-top:-8px;">‚ñº</button>
            </div>
        </div>
    </div>
    <input type="checkbox" id="haptic-switch" switch style="display:none">
    <div class="game-container">
        <div id="score-bar">Score: 0</div>
        <div id="speed-bar-container">
            <div id="speed-bar-labels">
                <span style="color:#f43f5e">Braking</span>
                <span style="color:#64748b;">Normal</span>
                <span style="color:#06b6d4">Accelerating</span>
            </div>
            <div id="speed-bar">
                <div id="speed-bar-indicator"></div>
            </div>
        </div>
        <div id="tilt-sensitivity-container">
            <span>Motion Sensitivity</span>
            <input id="tilt-sensitivity-bar" type="range" min="5" max="35" value="12">
            <span id="tilt-sensitivity-value">12</span>
        </div>
        <canvas id="gameCanvas" width="400" height="400"
            style="max-width:96vw;max-height:96vw;min-width:220px;min-height:220px;"></canvas>
    </div>
    <!-- Control Modal -->
    <div id="control-modal">
        <div>
            <h2 style="margin:0 0 18px;font-size:1.5em;">Choose Control Mode</h2>
            <button id="dpad-mode-btn">Touch D-Pad</button><br>
            <button id="tilt-mode-btn">Tilt (iPhone/Android)</button>
            <div id="tilt-steps" style="display:none;margin-top:18px;">
                <div id="tilt-permission-step">
                    <button id="tilt-perm-btn">Enable Tilt</button>
                </div>
                <div id="tilt-calibrate-step" style="display:none;">
                    <div style="margin-bottom:7px;">
                        Hold your phone in comfortable play position.<br>
                        Then tap Calibrate.
                    </div>
                    <button id="calibrate-btn">Calibrate</button>
                </div>
            </div>
        </div>
    </div>
    <script>
        // --- Haptic Feedback Utilities ---
        function isIOS() {
            return /iP(hone|od|ad)/.test(navigator.userAgent);
        }
        function isiOS18OrLater() {
            return isIOS() && /OS 1[8-9](_\d+)?\s/.test(navigator.userAgent);
        }
        function triggerHapticFallback() {
            const cb = document.getElementById('haptic-switch');
            cb.checked = !cb.checked;
        }
        function hapticFeedback(duration) {
            if ('vibrate' in navigator) {
                navigator.vibrate(duration || 30);
            } else if (isiOS18OrLater()) {
                triggerHapticFallback();
            }
        }
        // --- Device and UI Elements ---
        let controlModal = document.getElementById("control-modal");
        let dpadModeBtn = document.getElementById("dpad-mode-btn");
        let tiltModeBtn = document.getElementById("tilt-mode-btn");
        let tiltSteps = document.getElementById("tilt-steps");
        let tiltPermBtn = document.getElementById("tilt-perm-btn");
        let tiltCalibrateStep = document.getElementById("tilt-calibrate-step");
        let calibrateBtn = document.getElementById("calibrate-btn");
        let tiltSensitivityContainer = document.getElementById("tilt-sensitivity-container");
        let tiltSensitivityBar = document.getElementById("tilt-sensitivity-bar");
        let tiltSensitivityValue = document.getElementById("tilt-sensitivity-value");
        let pauseBtn = document.getElementById("pause-btn");
        let pausedOverlay = document.getElementById("paused-overlay");
        let pausedOverlayInner = document.getElementById("paused-overlay-inner");
        let dpadContainer = document.getElementById("dpad-container");
        let resetDpadBtn = document.getElementById("reset-dpad-btn");
        let dpadPlacementOverlay = document.getElementById("dpad-placement-overlay");
        // --- Game State ---
        let useTilt = false, tiltReady = false;
        let tiltSensitivity = 12;
        let baseGamma = 0, baseBeta = 0;
        let tiltGammaAvg = 0, tiltBetaAvg = 0;
        let smoothingFactor = 0.25;
        let gameStarted = false;
        let isPaused = false;
        let useDpad = false;
        let dpadPos = { x: null, y: null }; // absolute px, set after placement
        let dpadPlacementMode = false;
        let dpadDirection = null, dpadHoldStart = null, dpadHolding = false;
        // --- Dpad Acceleration
        const KEYBOARD_ACCEL = 7;
        const DPAD_ACCEL = 3; // less sensitive
        // --- Control Modal Selection Logic ---
        dpadModeBtn.onclick = function () {
            controlModal.style.display = "none";
            useDpad = true; useTilt = false;
            tiltSensitivityContainer.style.display = "none";
            setupDpad();
        };
        tiltModeBtn.onclick = function () {
            tiltSteps.style.display = "block";
            tiltPermBtn.disabled = false;
        };
        tiltPermBtn.onclick = function () {
            if (typeof DeviceOrientationEvent !== "undefined" && typeof DeviceOrientationEvent.requestPermission === "function") {
                DeviceOrientationEvent.requestPermission().then(response => {
                    if (response === "granted") {
                        tiltPermBtn.disabled = true;
                        tiltPermBtn.textContent = "Permission Granted!";
                        tiltCalibrateStep.style.display = "block";
                    } else {
                        alert("Permission denied.");
                    }
                });
            } else {
                tiltCalibrateStep.style.display = "block";
                tiltPermBtn.disabled = true;
                tiltPermBtn.textContent = "Permission Granted!";
            }
        };
        calibrateBtn.onclick = function () {
            window.addEventListener("deviceorientation", function once(e) {
                baseGamma = e.gamma || 0;
                baseBeta = e.beta || 0;
                tiltGammaAvg = baseGamma;
                tiltBetaAvg = baseBeta;
                tiltReady = true;
                controlModal.style.display = "none";
                startGameWithTilt();
                window.removeEventListener("deviceorientation", once);
            });
        };
        tiltSensitivityBar.oninput = function () {
            tiltSensitivity = Number(tiltSensitivityBar.value);
            tiltSensitivityValue.textContent = tiltSensitivity;
        };
        // --- Game Logic and Variables ---
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const scoreBar = document.getElementById('score-bar');
        const speedBar = document.getElementById('speed-bar');
        const speedBarIndicator = document.getElementById('speed-bar-indicator');
        let tileCount = 40;
        let gridSize = 10;
        // Dynamically set grid for mobile screens
        function adjustGridForScreen() {
            let size = Math.min(window.innerWidth * 0.96, window.innerHeight * 0.7, 400);
            if (size < 340) {
                tileCount = 16;
            } else if (size < 400) {
                tileCount = 22;
            } else {
                tileCount = 40;
            }
            gridSize = Math.floor(size / tileCount);
            canvas.width = gridSize * tileCount;
            canvas.height = gridSize * tileCount;
        }
        let snake, direction, nextDirection, food, score;
        let holdingKey = false;
        let heldDirection = null;
        let minSpeed = 25;
        let maxSlowSpeed = 200;
        let currentSpeed = 100;
        let accelerationStep = KEYBOARD_ACCEL;
        let decelerationStep = 6;
        let animationFrameId = null;
        let animState = "normal";
        let animTick = 0;
        let tiltMode = false;
        let lastTiltDir = null;
        function isTouchDevice() {
            return 'ontouchstart' in window || navigator.maxTouchPoints > 0;
        }
        function getNormalSpeed(score) {
            return Math.max(100 - Math.floor(score / 5) * 5, 45);
        }
        function isOppositeDirection(dir1, dir2) {
            return (
                (dir1 === 'left' && dir2 === 'right') ||
                (dir1 === 'right' && dir2 === 'left') ||
                (dir1 === 'up' && dir2 === 'down') ||
                (dir1 === 'down' && dir2 === 'up')
            );
        }
        function resetGameVars() {
            snake = [{ x: 10, y: 10 }];
            direction = 'right';
            nextDirection = 'right';
            food = getNewFoodPosition();
            score = 0;
            holdingKey = false;
            heldDirection = null;
            currentSpeed = getNormalSpeed(0);
            animState = "normal";
            animTick = 0;
            lastTiltDir = null;
        }
        function startGameWithTilt() {
            tiltMode = true;
            useTilt = true; useDpad = false;
            resetGameVars();
            tiltSensitivityContainer.style.display = "flex";
            pauseBtn.hidden = false;
            resetDpadBtn.hidden = true;
            dpadContainer.style.display = "none";
            window.addEventListener('deviceorientation', deviceTiltHandler);
            isPaused = false;
            hidePausedOverlay();
            gameStarted = true;
            accelerationStep = KEYBOARD_ACCEL;
            draw();
        }
        function startGameWithDpad() {
            tiltMode = false; useTilt = false; useDpad = true;
            resetGameVars();
            tiltSensitivityContainer.style.display = "none";
            pauseBtn.hidden = false;
            resetDpadBtn.hidden = false;
            isPaused = false;
            hidePausedOverlay();
            gameStarted = true;
            accelerationStep = DPAD_ACCEL;
            draw();
        }
        // --- D-Pad logic ---
        function setupDpad() {
            pauseBtn.hidden = false;
            resetDpadBtn.hidden = false;
            if (dpadPos.x === null || dpadPos.y === null) {
                showDpadPlacement();
            } else {
                dpadContainer.style.display = "block";
                positionDpad(dpadPos.x, dpadPos.y);
                startGameWithDpad();
            }
        }
        function showDpadPlacement() {
            dpadPlacementMode = true;
            dpadPlacementOverlay.style.display = "flex";
            pauseBtn.hidden = true;
            resetDpadBtn.hidden = true;
            dpadContainer.style.display = "none";
            isPaused = true;
        }
        function hideDpadPlacement() {
            dpadPlacementMode = false;
            dpadPlacementOverlay.style.display = "none";
            pauseBtn.hidden = false;
            resetDpadBtn.hidden = false;
            dpadContainer.style.display = "block";
            isPaused = false;
            startGameWithDpad();
        }
        dpadPlacementOverlay.addEventListener('click', function (e) {
            let x = e.touches ? e.touches[0].clientX : e.clientX;
            let y = e.touches ? e.touches[0].clientY : e.clientY;
            // Don't let dpad go offscreen
            let dpw = dpadContainer.offsetWidth || 92, dph = dpadContainer.offsetHeight || 92;
            x = Math.max(0, Math.min(window.innerWidth - dpw, x - dpw / 2));
            y = Math.max(0, Math.min(window.innerHeight - dph, y - dph / 2));
            dpadPos = { x, y };
            positionDpad(x, y);
            hideDpadPlacement();
        });
        function positionDpad(x, y) {
            dpadContainer.style.left = x + "px";
            dpadContainer.style.top = y + "px";
        }
        resetDpadBtn.onclick = showDpadPlacement;
        // --- D-Pad Button Handlers ---
        function dpadPress(direction) {
            if (dpadPlacementMode) return;
            if (direction !== nextDirection && !isOppositeDirection(direction, nextDirection)) {
                nextDirection = direction;
            }
            dpadDirection = direction;
            dpadHoldStart = Date.now();
            dpadHolding = true;
            holdingKey = true;
            heldDirection = direction;
        }
        function dpadRelease(direction) {
            dpadHolding = false;
            holdingKey = false;
            heldDirection = null;
        }
        ["up", "down", "left", "right"].forEach(dir => {
            let btn = document.getElementById('dpad-' + dir);
            btn.addEventListener('touchstart', e => { e.preventDefault(); dpadPress(dir); }, { passive: false });
            btn.addEventListener('mousedown', e => { e.preventDefault(); dpadPress(dir); });
            btn.addEventListener('touchend', e => { e.preventDefault(); dpadRelease(dir); }, { passive: false });
            btn.addEventListener('mouseup', e => { e.preventDefault(); dpadRelease(dir); });
            btn.addEventListener('mouseleave', e => { dpadRelease(dir); });
        });
        // --- Tap Key Controls for Desktop ---
        function tapKeydownHandler(e) {
            let pressed = false;
            switch (e.key) {
                case 'ArrowUp': case 'w': case 'W':
                    if (direction !== 'down') {
                        nextDirection = 'up'; pressed = true;
                    }
                    break;
                case 'ArrowDown': case 's': case 'S':
                    if (direction !== 'up') {
                        nextDirection = 'down'; pressed = true;
                    }
                    break;
                case 'ArrowLeft': case 'a': case 'A':
                    if (direction !== 'right') {
                        nextDirection = 'left'; pressed = true;
                    }
                    break;
                case 'ArrowRight': case 'd': case 'D':
                    if (direction !== 'left') {
                        nextDirection = 'right'; pressed = true;
                    }
                    break;
                case ' ':
                    togglePause();
                    break;
            }
            if (pressed) {
                holdingKey = true;
                heldDirection = nextDirection;
            } else if (
                (e.key === 'ArrowUp' && direction === 'down') ||
                (e.key === 'w' && direction === 'down') ||
                (e.key === 'ArrowDown' && direction === 'up') ||
                (e.key === 's' && direction === 'up') ||
                (e.key === 'ArrowLeft' && direction === 'right') ||
                (e.key === 'a' && direction === 'right') ||
                (e.key === 'ArrowRight' && direction === 'left') ||
                (e.key === 'd' && direction === 'left')
            ) {
                holdingKey = true;
                heldDirection = {
                    'ArrowUp': 'up', 'w': 'up', 'W': 'up',
                    'ArrowDown': 'down', 's': 'down', 'S': 'down',
                    'ArrowLeft': 'left', 'a': 'left', 'A': 'left',
                    'ArrowRight': 'right', 'd': 'right', 'D': 'right'
                }[e.key];
            }
        }
        function tapKeyupHandler(e) {
            if (
                (e.key === 'ArrowUp' && heldDirection === 'up') ||
                ((e.key === 'w' || e.key === 'W') && heldDirection === 'up') ||
                (e.key === 'ArrowDown' && heldDirection === 'down') ||
                ((e.key === 's' || e.key === 'S') && heldDirection === 'down') ||
                (e.key === 'ArrowLeft' && heldDirection === 'left') ||
                ((e.key === 'a' || e.key === 'A') && heldDirection === 'left') ||
                (e.key === 'ArrowRight' && heldDirection === 'right') ||
                ((e.key === 'd' || e.key === 'D') && heldDirection === 'right')
            ) {
                holdingKey = false;
                heldDirection = null;
            }
        }
        // --- Tilt Handler (with smoothing and sensitivity) ---
        function deviceTiltHandler(e) {
            if (!tiltMode || !tiltReady) return;
            tiltGammaAvg = tiltGammaAvg * (1 - smoothingFactor) + (e.gamma || 0) * smoothingFactor;
            tiltBetaAvg = tiltBetaAvg * (1 - smoothingFactor) + (e.beta || 0) * smoothingFactor;
            let dx = tiltGammaAvg - baseGamma;
            let dy = tiltBetaAvg - baseBeta;
            let newDir = null;
            if (dx > tiltSensitivity && direction !== 'left' && lastTiltDir !== 'right') {
                newDir = 'right';
            } else if (dx < -tiltSensitivity && direction !== 'right' && lastTiltDir !== 'left') {
                newDir = 'left';
            } else if (dy > tiltSensitivity && direction !== 'up' && lastTiltDir !== 'down') {
                newDir = 'down';
            } else if (dy < -tiltSensitivity && direction !== 'down' && lastTiltDir !== 'up') {
                newDir = 'up';
            }
            if (newDir) {
                nextDirection = newDir;
                holdingKey = true;
                heldDirection = newDir;
                lastTiltDir = newDir;
            } else {
                if (
                    (direction === 'left' && dx > tiltSensitivity / 2) ||
                    (direction === 'right' && dx < -tiltSensitivity / 2) ||
                    (direction === 'up' && dy > tiltSensitivity / 2) ||
                    (direction === 'down' && dy < -tiltSensitivity / 2)
                ) {
                    holdingKey = true;
                    heldDirection = (direction === 'left' || direction === 'right') ? (dx > 0 ? 'right' : 'left') : (dy > 0 ? 'down' : 'up');
                } else {
                    holdingKey = false;
                    heldDirection = null;
                    lastTiltDir = null;
                }
            }
        }
        // --- PAUSE FEATURE ---
        function togglePause() {
            if (!gameStarted) return;
            isPaused = !isPaused;
            if (isPaused) {
                showPausedOverlay();
            } else {
                hidePausedOverlay();
                draw();
            }
        }
        function resumeGame() {
            if (isPaused) {
                isPaused = false;
                hidePausedOverlay();
                draw();
            }
        }
        function showPausedOverlay() {
            pausedOverlay.style.display = "flex";
        }
        function hidePausedOverlay() {
            pausedOverlay.style.display = "none";
        }
        pauseBtn.onclick = togglePause;
        window.addEventListener('keydown', function (e) {
            if (e.key === 'Escape' || e.key === 'p' || e.key === 'P') {
                togglePause();
            }
        });
        // --- Main Game Loop ---
        function draw() {
            if (isPaused) return;
            let targetNormalSpeed = getNormalSpeed(score);
            if (holdingKey && heldDirection === direction && currentSpeed < targetNormalSpeed - 3) {
                animState = "accelerating";
            } else if (holdingKey && isOppositeDirection(heldDirection, direction) && currentSpeed > targetNormalSpeed + 3) {
                animState = "braking";
            } else {
                animState = "normal";
            }
            if (holdingKey && heldDirection === direction) {
                currentSpeed -= accelerationStep;
                if (currentSpeed < minSpeed) currentSpeed = minSpeed;
            } else if (holdingKey && isOppositeDirection(heldDirection, direction)) {
                currentSpeed += decelerationStep * 2;
                if (currentSpeed > maxSlowSpeed) currentSpeed = maxSlowSpeed;
            } else {
                if (currentSpeed > targetNormalSpeed) {
                    currentSpeed -= decelerationStep;
                    if (currentSpeed < targetNormalSpeed) currentSpeed = targetNormalSpeed;
                } else if (currentSpeed < targetNormalSpeed) {
                    currentSpeed += decelerationStep;
                    if (currentSpeed > targetNormalSpeed) currentSpeed = targetNormalSpeed;
                }
            }
            direction = nextDirection;
            const head = { ...snake[0] };
            switch (direction) {
                case 'up': head.y--; break;
                case 'down': head.y++; break;
                case 'left': head.x--; break;
                case 'right': head.x++; break;
            }
            snake.unshift(head);
            if (head.x < 0 || head.x >= tileCount || head.y < 0 || head.y >= tileCount) {
                gameOver(); return;
            }
            if (snake.slice(1).some(segment => segment.x === head.x && segment.y === head.y)) {
                gameOver(); return;
            }
            if (head.x === food.x && head.y === food.y) {
                score++;
                food = getNewFoodPosition();
            } else {
                snake.pop();
            }
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            ctx.save();
            ctx.shadowColor = '#ef4444aa';
            ctx.shadowBlur = 7;
            ctx.beginPath();
            ctx.arc(food.x * gridSize + gridSize / 2, food.y * gridSize + gridSize / 2, gridSize / 2 - 1, 0, Math.PI * 2);
            ctx.closePath();
            ctx.fillStyle = '#fb7185';
            ctx.fill();
            ctx.restore();
            animTick++;
            if (animTick > 10000) animTick = 0;
            for (let i = 0; i < snake.length; i++) {
                ctx.save();
                if (i === 0) {
                    let x = snake[i].x * gridSize + gridSize / 2;
                    let y = snake[i].y * gridSize + gridSize / 2;
                    if (animState === "accelerating") {
                        drawSpeedLines(ctx, x, y, direction, animTick);
                        drawPointyHead(ctx, x, y, direction);
                    } else if (animState === "braking") {
                        drawBrakeWave(ctx, x, y, animTick);
                        drawPuffyHead(ctx, x, y);
                    } else {
                        ctx.shadowColor = "#22d3ee";
                        ctx.shadowBlur = 6;
                        ctx.fillStyle = "#0ea5e9";
                        roundedRect(ctx, x - gridSize / 2, y - gridSize / 2, gridSize, gridSize, 3.5);
                        ctx.fill();
                    }
                } else {
                    ctx.shadowColor = "#a5f3fc66";
                    ctx.shadowBlur = 6;
                    ctx.fillStyle = "#38bdf8";
                    const x = snake[i].x * gridSize;
                    const y = snake[i].y * gridSize;
                    roundedRect(ctx, x, y, gridSize, gridSize, 3);
                    ctx.fill();
                }
                ctx.restore();
            }
            scoreBar.innerHTML = `Score: <span style="color:#06b6d4">${score}</span>`;
            updateSpeedBar(animState, currentSpeed, getNormalSpeed(score), minSpeed, maxSlowSpeed);
            animationFrameId = setTimeout(() => requestAnimationFrame(draw), currentSpeed);
        }
        function drawPointyHead(ctx, x, y, direction) {
            ctx.save();
            ctx.shadowColor = "#06b6d4";
            ctx.shadowBlur = 22;
            ctx.fillStyle = "#0ea5e9";
            ctx.strokeStyle = "#22d3ee";
            ctx.lineWidth = 2;
            let len = gridSize * 1.8, w = gridSize * 1.05;
            let base = gridSize * 0.7;
            ctx.beginPath();
            if (direction === 'right') {
                ctx.moveTo(x + len / 2, y);
                ctx.lineTo(x - base / 2, y - w / 2);
                ctx.lineTo(x - base / 2, y + w / 2);
            } else if (direction === 'left') {
                ctx.moveTo(x - len / 2, y);
                ctx.lineTo(x + base / 2, y - w / 2);
                ctx.lineTo(x + base / 2, y + w / 2);
            } else if (direction === 'up') {
                ctx.moveTo(x, y - len / 2);
                ctx.lineTo(x - w / 2, y + base / 2);
                ctx.lineTo(x + w / 2, y + base / 2);
            } else if (direction === 'down') {
                ctx.moveTo(x, y + len / 2);
                ctx.lineTo(x - w / 2, y - base / 2);
                ctx.lineTo(x + w / 2, y - base / 2);
            }
            ctx.closePath();
            ctx.fill();
            ctx.stroke();
            ctx.restore();
        }
        function drawSpeedLines(ctx, x, y, direction, tick) {
            ctx.save();
            ctx.globalAlpha = 0.42;
            ctx.strokeStyle = "#0ea5e9";
            ctx.lineWidth = 2.7;
            let spacing = 6, lines = 4;
            let offset = Math.sin(tick * 0.25) * 2;
            for (let i = 0; i < lines; i++) {
                let factor = i - (lines - 1) / 2;
                if (direction === 'right') {
                    ctx.beginPath();
                    ctx.moveTo(x - 14, y + factor * spacing + offset);
                    ctx.lineTo(x - 25, y + factor * spacing + offset);
                    ctx.stroke();
                } else if (direction === 'left') {
                    ctx.beginPath();
                    ctx.moveTo(x + 14, y + factor * spacing + offset);
                    ctx.lineTo(x + 25, y + factor * spacing + offset);
                    ctx.stroke();
                } else if (direction === 'up') {
                    ctx.beginPath();
                    ctx.moveTo(x + factor * spacing + offset, y + 14);
                    ctx.lineTo(x + factor * spacing + offset, y + 25);
                    ctx.stroke();
                } else if (direction === 'down') {
                    ctx.beginPath();
                    ctx.moveTo(x + factor * spacing + offset, y - 14);
                    ctx.lineTo(x + factor * spacing + offset, y - 25);
                    ctx.stroke();
                }
            }
            ctx.globalAlpha = 1;
            ctx.restore();
        }
        function drawPuffyHead(ctx, x, y) {
            ctx.save();
            ctx.shadowColor = "#fb7185";
            ctx.shadowBlur = 20;
            ctx.fillStyle = "#f59e42";
            ctx.beginPath();
            ctx.arc(x, y, gridSize * 0.87 + Math.sin(animTick * 0.20) * 2, 0, Math.PI * 2);
            ctx.closePath();
            ctx.fill();
            ctx.restore();
        }
        function drawBrakeWave(ctx, x, y, tick) {
            ctx.save();
            let baseR = gridSize * 1.1;
            for (let i = 0; i < 3; i++) {
                ctx.beginPath();
                ctx.globalAlpha = 0.21 - i * 0.05;
                ctx.strokeStyle = "#fb7185";
                ctx.lineWidth = 3 - i;
                let waveRadius = baseR + Math.abs(Math.sin(tick * 0.23 + i)) * (10 + i * 5);
                ctx.arc(x, y, waveRadius, 0, Math.PI * 2);
                ctx.stroke();
            }
            ctx.globalAlpha = 1;
            ctx.restore();
        }
        function updateSpeedBar(animState, currentSpeed, normalSpeed, minSpeed, maxSlowSpeed) {
            let val = 0;
            if (currentSpeed > normalSpeed) {
                val = -Math.min((currentSpeed - normalSpeed) / (maxSlowSpeed - normalSpeed), 1);
            } else if (currentSpeed < normalSpeed) {
                val = Math.min((normalSpeed - currentSpeed) / (normalSpeed - minSpeed), 1);
            }
            let bar = speedBar;
            let barIndicator = speedBarIndicator;
            let px = ((val + 1) / 2) * bar.offsetWidth;
            let width = bar.offsetWidth * 0.09 + Math.abs(val) * bar.offsetWidth * 0.4;
            px = Math.max(2, Math.min(bar.offsetWidth - width - 2, px - width / 2));
            let bg = "#93c5fd";
            if (animState === "accelerating") bg = "linear-gradient(90deg,#38bdf8 40%,#06b6d4 100%)";
            if (animState === "braking") bg = "linear-gradient(90deg,#fb7185 10%,#f43f5e 80%)";
            barIndicator.style.left = px + "px";
            barIndicator.style.width = width + "px";
            barIndicator.style.height = "100%";
            barIndicator.style.background = bg;
            barIndicator.style.boxShadow = (animState !== "normal")
                ? `0 0 16px 3px ${animState === "accelerating" ? "#06b6d4" : "#f43f5e"}99`
                : "none";
        }
        function getNewFoodPosition() {
            let pos;
            while (true) {
                pos = {
                    x: Math.floor(Math.random() * tileCount),
                    y: Math.floor(Math.random() * tileCount)
                };
                if (!snake.some(segment => segment.x === pos.x && segment.y === pos.y)) {
                    return pos;
                }
            }
        }
        function gameOver() {
            clearTimeout(animationFrameId);
            setTimeout(() => {
                alert(`Game Over! Your score: ${score}`);
                resetGameVars();
                draw();
            }, 200);
        }
        function roundedRect(ctx, x, y, w, h, r) {
            ctx.beginPath();
            ctx.moveTo(x + r, y);
            ctx.lineTo(x + w - r, y);
            ctx.quadraticCurveTo(x + w, y, x + w, y + r);
            ctx.lineTo(x + w, y + h - r);
            ctx.quadraticCurveTo(x + w, y + h, x + w - r, y + h);
            ctx.lineTo(x + r, y + h);
            ctx.quadraticCurveTo(x, y + h, x, y + h - r);
            ctx.lineTo(x, y + r);
            ctx.quadraticCurveTo(x, y, x + r, y);
            ctx.closePath();
        }
        // Service Worker registration for PWA
        if ('serviceWorker' in navigator) {
            window.addEventListener('load', function () {
                navigator.serviceWorker.register('./service-worker.js');
            });
        }
        // --- Responsive Canvas Sizing ---
        function fitCanvas() {
            let size = Math.min(window.innerWidth * 0.96, window.innerHeight * 0.7, 400);
            canvas.style.width = size + "px";
            canvas.style.height = size + "px";
            adjustGridForScreen();
        }
        window.addEventListener("resize", fitCanvas);
        fitCanvas();
        // Attach desktop controls
        if (!isTouchDevice()) {
            document.addEventListener('keydown', tapKeydownHandler);
            document.addEventListener('keyup', tapKeyupHandler);
        }
        // Start modal on load
        window.onload = function () {
            controlModal.style.display = "flex";
            pauseBtn.hidden = true;
            resetDpadBtn.hidden = true;
        };
    </script>
</body>

</html>