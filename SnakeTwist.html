<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no, viewport-fit=cover">
    <title>Snake Game (Responsive, D-Pad/Tilt)</title>
    <!-- Modern Inter Font from Google Fonts -->
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@500;700&display=swap" rel="stylesheet">
    <!-- PWA Meta Tags -->
    <meta name="theme-color" content="#0ea5e9">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <!-- Favicon (optional, use your own path) -->
    <link rel="icon" href="favicon.ico">
    <style>
        body {
            padding-bottom: env(safe-area-inset-bottom);
        }

        html,


        body {
            background: linear-gradient(135deg, #e9e9f2 0%, #f6faff 100%);
            min-height: 100vh;
            margin: 0;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            font-family: 'Inter', 'Segoe UI', Arial, sans-serif;
        }

        body.dark-mode {
            background: linear-gradient(135deg, #222736 0%, #18181d 100%);
        }

        body.dark-mode #score-bar,
        body.dark-mode #paused-overlay-inner,
        body.dark-mode #control-modal>div,
        body.dark-mode #tilt-sensitivity-container {
            background: #222b3a !important;
            color: #fff !important;
            box-shadow: 0 2px 8px #11131b80 !important;
        }

        body.dark-mode #speed-bar {
            background: #222b3a;
            border-color: #0ea5e9;
        }

        body.dark-mode #speed-bar-labels>span:nth-child(1) {
            color: #f43f5e !important;
        }

        body.dark-mode #speed-bar-labels>span:nth-child(2) {
            color: #e0e7ef !important;
        }

        body.dark-mode #speed-bar-labels>span:nth-child(3) {
            color: #06b6d4 !important;
        }

        body.dark-mode #speed-bar-indicator {
            box-shadow: 0 0 20px #0ea5e9a8 !important;
        }

        body.dark-mode canvas {
            background: #181d29 !important;
            border-color: #0ea5e9 !important;
            box-shadow: 0 8px 32px #0ea5e933, 0 0 0 2px #3ee9fd88;
        }

        body.dark-mode .dpad {
            background: transparent !important;
            box-shadow: none !important;
        }

        body.dark-mode .dpad-btn {
            background: linear-gradient(135deg, #181d29 65%, #0ea5e9 100%);
            color: #fff;
        }

        body.dark-mode .dpad-btn:active {
            background: #0ea5e9;
        }

        body.dark-mode #dpad-placement-message {
            background: #252b3b;
            color: #0ea5e9;
        }

        body.dark-mode #tilt-sensitivity-bar {
            background: #2e3447;
        }

        body.dark-mode #paused-overlay {
            background: rgba(0, 0, 0, 0.55);
        }

        #dark-mode-btn {
            position: fixed;
            top: 8px;
            right: 110px;
            z-index: 3000;
            background: #fff;
            border: 2px solid #0ea5e9;
            color: #0ea5e9;
            border-radius: 12px;
            font-size: 1.15em;
            width: 42px;
            height: 42px;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            box-shadow: 0 2px 8px #0ea5e933;
            transition: background 0.14s, box-shadow 0.14s;
            font-family: 'Inter', 'Segoe UI', Arial, sans-serif;
            margin-left: 8px;
        }

        #dark-mode-btn[hidden] {
            display: none;
        }

        .game-container {
            width: 100vw;
            max-width: 100vw;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 2vw;
            box-sizing: border-box;
        }

        #score-bar {
            font-family: 'Inter', 'Segoe UI', Arial, sans-serif;
            font-size: 1.1rem;
            font-weight: 600;
            color: #334155;
            background: #fff;
            padding: 7px 18px;
            border-radius: 18px;
            margin-top: 2vw;
            margin-bottom: 1vw;
            box-shadow: 0 2px 8px #93c5fd33;
            user-select: none;
        }

        #speed-bar-container {
            width: 90vw;
            max-width: 400px;
            margin-bottom: 8px;
            display: flex;
            flex-direction: column;
            align-items: center;
            font-family: 'Inter', 'Segoe UI', Arial, sans-serif;
        }

        #speed-bar-labels {
            width: 100%;
            display: flex;
            justify-content: space-between;
            font-size: 11px;
            color: #64748b;
            padding: 0 6px;
            box-sizing: border-box;
        }

        #speed-bar {
            width: 100%;
            height: 16px;
            background: #f3f4f6;
            border-radius: 8px;
            border: 2px solid #cbd5e1;
            box-shadow: 0 2px 8px #bae6fd66;
            position: relative;
            overflow: hidden;
            margin-bottom: 2px;
            margin-top: 3px;
        }

        #speed-bar-indicator {
            position: absolute;
            top: 0;
            bottom: 0;
            height: 100%;
            border-radius: 8px;
        }

        #tilt-sensitivity-container {
            margin: 7px 0 0 0;
            padding: 7px;
            border-radius: 8px;
            background: #f6faff;
            box-shadow: 0 2px 10px #bae6fd33;
            display: none;
            align-items: center;
            justify-content: center;
            gap: 12px;
        }

        #tilt-sensitivity-bar {
            width: 120px;
        }

        canvas {
            background: #f8fafc;
            border: 4px solid #38bdf8;
            border-radius: 18px;
            box-shadow: 0 8px 32px #38bdf866, 0 0 0 2px #bae6fd88;
            display: block;
            margin-top: 10px;
            max-width: 98vw;
            max-height: 56vw;
            width: 98vw;
            height: auto;
            min-width: 110px;
            min-height: 110px;
            touch-action: none;
            -webkit-user-select: none;
            user-select: none;
        }

        #pause-btn,
        #reset-dpad-btn {
            position: fixed;
            top: 8px;
            z-index: 201;
            background: #fff;
            border: 2px solid #38bdf8;
            color: #0ea5e9;
            border-radius: 12px;
            font-size: 1.15em;
            width: 42px;
            height: 42px;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            box-shadow: 0 2px 8px #38bdf833;
            transition: background 0.14s, box-shadow 0.14s;
            font-family: 'Inter', 'Segoe UI', Arial, sans-serif;
            margin-left: 8px;
        }

        #pause-btn {
            right: 14px;
        }

        #reset-dpad-btn {
            right: 64px;
        }

        #pause-btn[hidden],
        #reset-dpad-btn[hidden] {
            display: none;
        }

        #paused-overlay {
            backdrop-filter: blur(10px);
            background: rgba(40, 50, 70, 0.16);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 3000;
            transition: background 0.3s;
            position: fixed;
            left: 0;
            top: 0;
            width: 100vw;
            height: 100vh;
        }

        #paused-overlay-inner {
            background: rgba(255, 255, 255, 0.82);
            border-radius: 18px;
            min-width: 220px;
            box-shadow: 0 8px 36px #3ae6fd22;
            text-align: center;
            padding: 34px 26px 26px 26px;
            font-family: 'Inter', 'Segoe UI', Arial, sans-serif;
            border: 1px solid #bae6fd33;
            transition: background 0.25s;
            color: #0ea5e9;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 18px;
        }

        body.dark-mode #paused-overlay-inner {
            background: rgba(28, 33, 48, 0.98);
            color: #c7eafe;
            box-shadow: 0 10px 44px #181d29bb, 0 0 0 1px #0ea5e93b;
        }

        #paused-overlay-inner .paused-icon {
            margin-bottom: 6px;
        }

        #paused-overlay-inner svg {
            display: block;
            margin: 0 auto;
        }

        .paused-title {
            font-size: 1.4em;
            font-weight: 700;
            color: #0ea5e9;
            letter-spacing: 0.03em;
            margin: 12px 0 6px 0;
        }

        .paused-score {
            font-size: 1em;
            color: #64748b;
            margin-bottom: 18px;
        }

        .pause-btn-main,
        .pause-btn-secondary {
            font-family: 'Inter', 'Segoe UI', Arial, sans-serif;
            border: none;
            border-radius: 10px;
            padding: 10px 32px;
            font-size: 1.03em;
            font-weight: 600;
            cursor: pointer;
            margin: 0 4px 5px 4px;
            box-shadow: none;
            outline: none;
            transition: background 0.15s, color 0.15s, border 0.15s;
        }

        .pause-btn-main {
            background: linear-gradient(90deg, #38bdf8 40%, #0ea5e9 100%);
            color: #fff;
        }

        .pause-btn-main:hover,
        .pause-btn-main:active {
            background: #0ea5e9;
        }

        .pause-btn-secondary {
            background: #fff;
            color: #0ea5e9;
            border: 1.5px solid #38bdf8;
        }

        .pause-btn-secondary:hover,
        .pause-btn-secondary:active {
            background: #e0f2fe;
            color: #0284c7;
        }

        body.dark-mode .pause-btn-secondary {
            background: #181d29;
            color: #38bdf8;
            border: 1.5px solid #0ea5e9;
        }

        #dpad-container {
            position: fixed;
            left: 50%;
            transform: translateX(-50%);
            bottom: calc(3vw + env(safe-area-inset-bottom));
            z-index: 210;
            display: none;
            pointer-events: none;
            overscroll-behavior: contain;
            touch-action: none;
        }

        @media (max-width: 700px) {
            #dpad-container {
                bottom: calc(5vw + env(safe-area-inset-bottom)) !important;
                pointer-events: auto;
            }
        }

        @media (hover: hover) {

            /* desktop / devices that have a mouse */
            #dpad-container,
            #reset-dpad-btn {
                display: none !important;
            }

            #pause-btn,
            #dark-mode-btn {
                display: flex !important;
            }
        }

        .dpad {
            display: grid;
            grid-template-columns: repeat(3, 60px);
            grid-template-rows: repeat(3, 60px);
            gap: 12px;
            justify-content: center;
            align-content: center;
            pointer-events: auto;
            overscroll-behavior: contain;
            touch-action: none;
        }

        #dpad-up {
            grid-column: 2;
            grid-row: 1;
        }

        #dpad-left {
            grid-column: 1;
            grid-row: 2;
        }

        #dpad-right {
            grid-column: 3;
            grid-row: 2;
        }

        #dpad-down {
            grid-column: 2;
            grid-row: 3;
        }

        .dpad-btn {
            background: transparent;
            border: none;
            margin: 8px;
            padding: 0;
            border-radius: 50%;
            box-shadow: none;
            width: 60px;
            height: 60px;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: background 0.15s, border 0.15s;
            touch-action: none;
            overscroll-behavior: contain;
        }

        .dpad-btn:active {
            background: #bae6fd66;
        }

        body.dark-mode .dpad {
            background: transparent !important;
            box-shadow: none !important;
        }

        body.dark-mode .dpad-btn {
            background: #222b3a;
            border: none;
            color: #38bdf8;
        }

        body.dark-mode .dpad-btn:active {
            background: #0ea5e9;
        }

        #dpad-container,
        .dpad,
        .dpad-btn {
            user-select: none;
            -webkit-user-select: none;
            outline: none !important;
        }

        .dpad-btn {
            -webkit-tap-highlight-color: transparent;
            box-shadow: 0 2px 18px #38bdf866;
        }

        #dpad-up,
        #dpad-down {
            width: 60px !important;
            height: 60px !important;
        }

        #dpad-placement-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            background: rgba(0, 0, 0, 0.32);
            z-index: 3000;
            display: none;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            font-family: 'Inter', 'Segoe UI', Arial, sans-serif;
        }

        #dpad-placement-message {
            color: #38bdf8;
            font-size: 2em;
            font-weight: bold;
            background: #fff;
            padding: 36px 32px;
            border-radius: 22px;
            box-shadow: 0 4px 32px #38bdf822;
            opacity: 0.95;
        }

        @media (max-width: 700px) {
            canvas#gameCanvas {
                width: 90vw !important;
                height: 90vw !important;
                max-width: none;
                max-height: none;
            }

            #dpad-container {
                position: relative !important;
                left: auto !important;
                transform: none !important;
                bottom: auto !important;
                margin: 2vw auto 0 !important;
                pointer-events: auto;
            }

            .game-container {
                margin-top: 2vw !important;
            }

            #score-bar {
                margin-top: 1vw !important;
                margin-bottom: 1vw !important;
            }

            #speed-bar-container {
                margin-bottom: 2vw;
            }

            canvas#gameCanvas {
                margin-top: 2vw;
                max-width: 98vw;
                max-height: 80vw;
                min-width: 110px;
                min-height: 110px;
            }

            #pause-btn,
            #reset-dpad-btn {
                width: 37px;
                height: 37px;
                font-size: 1em;
                top: 4px;
            }

            #pause-btn {
                right: 10px;
            }

            #reset-dpad-btn {
                right: 50px;
            }

            #dark-mode-btn {
                width: 37px;
                height: 37px;
                font-size: 1em;
                top: 4px;
                right: 90px;
            }

            #tilt-sensitivity-bar {
                width: 80px;
            }

            .dpad-btn {
                margin: 8px !important;
                width: 60px !important;
                height: 60px !important;
            }
        }
    </style>
</head>

<body>
    <button id="pause-btn" title="Pause/Resume" hidden>
        <svg width="26" height="26" viewBox="0 0 44 44" fill="none">
            <rect x="10" y="8" width="7" height="28" rx="3" fill="#0ea5e9" />
            <rect x="27" y="8" width="7" height="28" rx="3" fill="#0ea5e9" />
        </svg>
    </button>
    <button id="reset-dpad-btn" title="Reset D-Pad" hidden>
        <svg width="26" height="26" viewBox="0 0 44 44" fill="none">
            <circle cx="22" cy="22" r="16" stroke="#0ea5e9" stroke-width="3" />
            <circle cx="22" cy="22" r="4" fill="#0ea5e9" />
            <line x1="22" y1="6" x2="22" y2="16" stroke="#0ea5e9" stroke-width="2.2" />
            <line x1="22" y1="28" x2="22" y2="38" stroke="#0ea5e9" stroke-width="2.2" />
            <line x1="6" y1="22" x2="16" y2="22" stroke="#0ea5e9" stroke-width="2.2" />
            <line x1="28" y1="22" x2="38" y2="22" stroke="#0ea5e9" stroke-width="2.2" />
        </svg>
    </button>
    <button id="dark-mode-btn" title="Toggle Dark Mode" hidden>
        <svg id="dark-mode-svg" width="26" height="26" viewBox="0 0 44 44" fill="none">
            <path id="dark-mode-icon-moon"
                d="M31.5 28.5C27.5 34.5 19.5 34.5 15.5 28.5C11.5 22.5 15.5 14.5 22 14.5C23.6 14.5 25.1 14.9 26.4 15.7C25.2 17.8 24.8 20.3 25.6 22.5C26.5 25.2 29.4 27 31.5 28.5Z"
                fill="#0ea5e9" />
            <circle id="dark-mode-icon-sun" cx="22" cy="22" r="9" stroke="#0ea5e9" stroke-width="2" opacity="0" />
            <g id="dark-mode-rays" opacity="0">
                <line x1="22" y1="3" x2="22" y2="9" stroke="#0ea5e9" stroke-width="2" />
                <line x1="22" y1="35" x2="22" y2="41" stroke="#0ea5e9" stroke-width="2" />
                <line x1="3" y1="22" x2="9" y2="22" stroke="#0ea5e9" stroke-width="2" />
                <line x1="35" y1="22" x2="41" y2="22" stroke="#0ea5e9" stroke-width="2" />
                <line x1="9.6" y1="9.6" x2="14.2" y2="14.2" stroke="#0ea5e9" stroke-width="2" />
                <line x1="29.8" y1="29.8" x2="34.4" y2="34.4" stroke="#0ea5e9" stroke-width="2" />
                <line x1="9.6" y1="34.4" x2="14.2" y2="29.8" stroke="#0ea5e9" stroke-width="2" />
                <line x1="29.8" y1="14.2" x2="34.4" y2="9.6" stroke="#0ea5e9" stroke-width="2" />
            </g>
        </svg>
    </button>
    <div id="paused-overlay">
        <div id="paused-overlay-inner">
            <div class="paused-icon">
                <svg width="52" height="52" viewBox="0 0 52 52" fill="none">
                    <rect x="13" y="12" width="8" height="28" rx="4" fill="#0ea5e9" />
                    <rect x="31" y="12" width="8" height="28" rx="4" fill="#0ea5e9" />
                </svg>
            </div>
            <div class="paused-title" id="paused-title">Paused</div>
            <div class="paused-score" id="paused-score-container">Score: <span id="paused-score-value">0</span></div>
            <button class="pause-btn-main" id="overlay-main-btn">Resume</button>
            <button class="pause-btn-secondary" id="overlay-secondary-btn">Restart</button>
            <button class="pause-btn-secondary" id="overlay-dark-btn">Toggle Dark Mode</button>
        </div>
    </div>

    <input type="checkbox" id="haptic-switch" switch style="display:none">
    <div class="game-container">
        <div id="score-bar">Score: 0</div>
        <div id="speed-bar-container">
            <div id="speed-bar-labels">
                <span style="color:#f43f5e">Braking</span>
                <span style="color:#64748b;">Normal</span>
                <span style="color:#06b6d4">Accelerating</span>
            </div>
            <div id="speed-bar">
                <div id="speed-bar-indicator"></div>
            </div>
        </div>
        <div id="tilt-sensitivity-container">
            <span>Motion Sensitivity</span>
            <input id="tilt-sensitivity-bar" type="range" min="5" max="35" value="12">
            <span id="tilt-sensitivity-value">12</span>
        </div>
        <canvas id="gameCanvas" width="400" height="400"></canvas>
        <div id="dpad-container">
            <div class="dpad">
                <button class="dpad-btn" id="dpad-up"><svg width="32" height="32">
                        <circle cx="16" cy="16" r="14" fill="#fff" stroke="#0ea5e9" stroke-width="2" />
                        <polygon points="16,7 23,22 9,22" fill="#0ea5e9" />
                    </svg></button>
                <button class="dpad-btn" id="dpad-left"><svg width="32" height="32">
                        <circle cx="16" cy="16" r="14" fill="#fff" stroke="#0ea5e9" stroke-width="2" />
                        <polygon points="7,16 22,23 22,9" fill="#0ea5e9" />
                    </svg></button>
                <button class="dpad-btn" id="dpad-right"><svg width="32" height="32">
                        <circle cx="16" cy="16" r="14" fill="#fff" stroke="#0ea5e9" stroke-width="2" />
                        <polygon points="25,16 10,9 10,23" fill="#0ea5e9" />
                    </svg></button>
                <button class="dpad-btn" id="dpad-down"><svg width="32" height="32">
                        <circle cx="16" cy="16" r="14" fill="#fff" stroke="#0ea5e9" stroke-width="2" />
                        <polygon points="16,25 9,10 23,10" fill="#0ea5e9" />
                    </svg></button>
            </div>
        </div>
    </div>

    <div id="control-modal"
        style="display:none;position:fixed;left:0;top:0;width:100vw;height:100vh;background:rgba(0,0,0,0.7);z-index:5000;align-items:center;justify-content:center;">
        <div
            style="background:#fff;padding:26px 18px 18px 18px;border-radius:22px;text-align:center;min-width:180px;max-width:92vw;">
            <h2 style="margin:0 0 12px;font-size:1.15em;">Choose Control Mode</h2>
            <button id="dpad-mode-btn"
                style="margin-bottom:8px;padding:8px 25px;border-radius:8px;border:none;background:#38bdf8;color:#fff;cursor:pointer;font-size:1.07em;">Touch
                D-Pad</button><br>
            <button id="tilt-mode-btn"
                style="padding:8px 25px;border-radius:8px;border:none;background:#06b6d4;color:#fff;cursor:pointer;font-size:1.07em;">Tilt
                (iPhone/Android)</button>
            <div id="tilt-steps" style="display:none;margin-top:12px;">
                <div id="tilt-permission-step">
                    <button id="tilt-perm-btn">Enable Tilt</button>
                </div>
                <div id="tilt-calibrate-step" style="display:none;">
                    <div style="margin-bottom:7px;">
                        Hold your phone in comfortable play position.<br>
                        Then tap Calibrate.
                    </div>
                    <button id="calibrate-btn">Calibrate</button>
                </div>
            </div>
        </div>
    </div>
    <script>
        // Helper functions
        function isIOS() { return /iP(hone|od|ad)/.test(navigator.userAgent); }
        function isiOS18OrLater() { return isIOS() && /OS 1[8-9](_\d+)?\s/.test(navigator.userAgent); }
        function isTouchDevice() { return 'ontouchstart' in window || navigator.maxTouchPoints > 0; }
        function triggerHapticFallback() {
            const cb = document.getElementById('haptic-switch');
            cb.checked = !cb.checked;
        }
        function hapticFeedback(duration) {
            if ('vibrate' in navigator) navigator.vibrate(duration || 30);
            else if (isiOS18OrLater()) triggerHapticFallback();
        }

        // UI element references
        const controlModal = document.getElementById("control-modal");
        const dpadModeBtn = document.getElementById("dpad-mode-btn");
        const tiltModeBtn = document.getElementById("tilt-mode-btn");
        const tiltSteps = document.getElementById("tilt-steps");
        const tiltPermBtn = document.getElementById("tilt-perm-btn");
        const tiltCalibrateStep = document.getElementById("tilt-calibrate-step");
        const calibrateBtn = document.getElementById("calibrate-btn");
        const tiltSensitivityContainer = document.getElementById("tilt-sensitivity-container");
        const tiltSensitivityBar = document.getElementById("tilt-sensitivity-bar");
        const tiltSensitivityValue = document.getElementById("tilt-sensitivity-value");
        const pauseBtn = document.getElementById("pause-btn");
        const pausedOverlay = document.getElementById("paused-overlay");
        const dpadContainer = document.getElementById("dpad-container");
        const resetDpadBtn = document.getElementById("reset-dpad-btn");
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const scoreBar = document.getElementById('score-bar');
        const speedBar = document.getElementById('speed-bar');
        const speedBarIndicator = document.getElementById('speed-bar-indicator');
        const darkModeBtn = document.getElementById('dark-mode-btn');

        // Game state
        let dpadListenersAdded = false; // Track if listeners are added
        let lastDrawDirection = 'right';   // track previous draw direction
        let dpadPlacementMode = false;     // placement feature disabled
        let useTilt = false, tiltReady = false, useDpad = false;
        let tiltSensitivity = 12,     // still drives the UI slider (optional)
            baseGamma = 0, baseBeta = 0;

        // --- D-Pad Swipe Support ---
        let swipeStartX = null, swipeStartY = null;
        dpadContainer.addEventListener('touchstart', function (e) {
            if (e.touches.length === 1) {
                swipeStartX = e.touches[0].clientX;
                swipeStartY = e.touches[0].clientY;
            }
        }, { passive: false });

        dpadContainer.addEventListener('touchmove', function (e) {
            if (swipeStartX === null || swipeStartY === null) return;
            const t = e.touches[0];
            const dx = t.clientX - swipeStartX;
            const dy = t.clientY - swipeStartY;
            const absDx = Math.abs(dx), absDy = Math.abs(dy);
            const threshold = 30;
            if (absDx < threshold && absDy < threshold) return;
            let dir = absDx > absDy ? (dx > 0 ? 'right' : 'left') : (dy > 0 ? 'down' : 'up');
            dpadPress(dir);
            dpadRelease(dir);
            // Instead of resetting to null, update to current touch position for continuous detection
            swipeStartX = t.clientX;
            swipeStartY = t.clientY;
        }, { passive: false });

        dpadContainer.addEventListener('touchend', function (e) {
            swipeStartX = null; swipeStartY = null;
        }, { passive: false });

        dpadContainer.addEventListener('touchcancel', function () {
            swipeStartX = null; swipeStartY = null;
        });

        /* Tilt‑control constants & state */
        const DEAD = 4, ACT = 14, FILTER = 0.10;   // degrees / EMA α
        let rawTilt = { x: 0, y: 0 },
            smoothTilt = { x: 0, y: 0 },
            tiltOK = false,
            tiltPower = 1;             // 0‒1 analogue value, 1 for keyboard/D‑pad
        let isPaused = false, gameStarted = false;
        let dpadDirection = null, dpadHoldStart = null, dpadHolding = false;
        const KEYBOARD_ACCEL = 7, DPAD_ACCEL = 3;
        const ACCEL_RATE = 0.8;  // Lower for slower acceleration
        let tileCount = 40, gridSize = 10, minSpeed = 25, maxSlowSpeed = 200;
        let snake, direction, nextDirection, food, score, holdingKey = false, heldDirection = null;
        let currentSpeed = 100, accelerationStep = KEYBOARD_ACCEL, decelerationStep = 6, animationFrameId = null, animState = "normal", animTick = 0, tiltMode = false, lastTiltDir = null;
        // Animation variables for smooth movement
        let animProgress = 1;
        let moveDuration = 1;
        let lastFrameTime = 0;
        let gameOverTriggered = false;
        let particles = [];
        let tunnelAngle = 0; // For the tunnel's inertial direction
        let arrowMorph = 0;
        let showStartOverlay = true;
        function showStartOverlayFn() {
            pausedOverlay.style.display = "flex";
            document.getElementById('paused-title').textContent = "Snake Twist";
            document.getElementById('paused-score-container').style.display = "none";
            // Clean button listeners
            let mainBtn = document.getElementById('overlay-main-btn');
            let newMainBtn = mainBtn.cloneNode(true);
            mainBtn.parentNode.replaceChild(newMainBtn, mainBtn);
            newMainBtn.textContent = "Start Game";
            newMainBtn.onclick = function () {
                showStartOverlay = false;
                pausedOverlay.style.display = "none";
                if (!isTouchDevice()) startGameWithKeyboard();
            };
            // Only start button visible, no secondary button
            document.getElementById('overlay-secondary-btn').style.display = "none";
            // Clean and set dark mode overlay button
            let darkBtn = document.getElementById('overlay-dark-btn');
            let newDarkBtn = darkBtn.cloneNode(true);
            darkBtn.parentNode.replaceChild(newDarkBtn, darkBtn);
            newDarkBtn.onclick = () => darkModeBtn.click();
            if (pauseBtn) pauseBtn.hidden = true;
        }

        function dirToAngle(dir) {
            if (dir === "right") return 0;
            if (dir === "down") return Math.PI / 2;
            if (dir === "left") return Math.PI;
            if (dir === "up") return -Math.PI / 2;
            return 0;
        }

        function spawnParticles(x, y, color, count, speed = 2.7, spread = 1.3) {
            for (let i = 0; i < count; i++) {
                let angle = Math.random() * Math.PI * 2;
                let mag = speed * (0.65 + Math.random() * spread);
                particles.push({
                    x: x, y: y,
                    vx: Math.cos(angle) * mag,
                    vy: Math.sin(angle) * mag,
                    alpha: 1,
                    color: color,
                    life: 17 + Math.random() * 9
                });
            }
        }
        function updateAndDrawParticles(ctx) {
            for (let i = particles.length - 1; i >= 0; i--) {
                let p = particles[i];
                p.x += p.vx;
                p.y += p.vy;
                p.vx *= 0.93;
                p.vy *= 0.93;
                p.alpha *= 0.94;
                p.life--;
                ctx.save();
                ctx.globalAlpha = Math.max(0, p.alpha * (p.life / 20));
                ctx.fillStyle = p.color;
                ctx.beginPath();
                ctx.arc(p.x, p.y, 4, 0, Math.PI * 2);
                ctx.fill();
                ctx.restore();
                if (p.life < 1 || p.alpha < 0.05) {
                    particles.splice(i, 1);
                }
            }
        }

        function restartGame() {
            // Reset game state
            gameOverTriggered = false;
            resetGameVars();
            isPaused = false;
            hidePausedOverlay();
            // Start the game loop using the current control mode
            if (useDpad) {
                animationFrameId = requestAnimationFrame(gameLoop);
            } else if (useTilt) {
                animationFrameId = requestAnimationFrame(gameLoop);
            } else {
                animationFrameId = requestAnimationFrame(gameLoop);
            }
        }

        // Responsive canvas sizing
        function adjustGridForScreen() {
            tileCount = 40;
            gridSize = 10;
            canvas.width = 400;
            canvas.height = 400;
        }
        function fitCanvas() {
            // Responsive, sharp canvas for mobile/desktop
            let isMobile = window.innerWidth < 700 || isTouchDevice();
            let dpr = window.devicePixelRatio || 1;
            if (isMobile) {
                let size = Math.min(window.innerWidth, window.innerHeight) * 0.90;
                canvas.width = Math.round(size * dpr);
                canvas.height = Math.round(size * dpr);
                canvas.style.width = size + "px";
                canvas.style.height = size + "px";
                gridSize = canvas.width / tileCount;
            } else {
                canvas.width = 400 * dpr;
                canvas.height = 400 * dpr;
                canvas.style.width = "400px";
                canvas.style.height = "400px";
                gridSize = canvas.width / tileCount;
            }
        }
        window.addEventListener("resize", fitCanvas);
        fitCanvas();

        function getNormalSpeed(score) {
            return Math.max(100 - Math.floor(score / 5) * 5, 45);
        }
        function isOppositeDirection(dir1, dir2) {
            return (
                (dir1 === 'left' && dir2 === 'right') ||
                (dir1 === 'right' && dir2 === 'left') ||
                (dir1 === 'up' && dir2 === 'down') ||
                (dir1 === 'down' && dir2 === 'up')
            );
        }
        function resetGameVars() {
            // Cancel any previous animation frame before starting a new game loop
            if (animationFrameId !== null) {
                cancelAnimationFrame(animationFrameId);
                animationFrameId = null;
            }
            // Each segment tracks x, y, realX, realY, prevX, prevY
            snake = [{ x: 10, y: 10, realX: 10, realY: 10, prevX: 10, prevY: 10 }];
            direction = 'right';
            nextDirection = 'right';
            food = getNewFoodPosition();
            score = 0;
            holdingKey = false;
            heldDirection = null;
            currentSpeed = getNormalSpeed(0);
            animState = "normal";
            animTick = 0;
            lastTiltDir = null;
            animProgress = 1;
            tunnelAngle = dirToAngle(direction)
            // Ensure this is always set last
            gameOverTriggered = false;
        }

        // Control mode logic
        dpadModeBtn.onclick = function () {
            controlModal.style.display = "none";
            useDpad = true; useTilt = false;
            tiltSensitivityContainer.style.display = "none";
            setupDpad();
        };
        tiltModeBtn.onclick = function () {
            tiltSteps.style.display = "block";
            tiltPermBtn.disabled = false;
        };
        tiltPermBtn.onclick = function () {
            if (typeof DeviceOrientationEvent !== "undefined" && typeof DeviceOrientationEvent.requestPermission === "function") {
                DeviceOrientationEvent.requestPermission().then(response => {
                    if (response === "granted") {
                        tiltPermBtn.disabled = true;
                        tiltPermBtn.textContent = "Permission Granted!";
                        tiltCalibrateStep.style.display = "block";
                    } else alert("Permission denied.");
                });
            } else {
                tiltCalibrateStep.style.display = "block";
                tiltPermBtn.disabled = true;
                tiltPermBtn.textContent = "Permission Granted!";
            }
        };
        calibrateBtn.onclick = function () {
            window.addEventListener("deviceorientation", function once(e) {
                baseGamma = e.gamma || 0;
                baseBeta = e.beta || 0;
                tiltGammaAvg = baseGamma;
                tiltBetaAvg = baseBeta;
                tiltReady = true;
                controlModal.style.display = "none";
                startGameWithTilt();
                window.removeEventListener("deviceorientation", once);
            });
        };
        tiltSensitivityBar.oninput = function () {
            tiltSensitivity = Number(tiltSensitivityBar.value);
            tiltSensitivityValue.textContent = tiltSensitivity;
        };

        // --- Start functions ---
        function startGameWithTilt() {
            tiltMode = true; useTilt = true; useDpad = false;
            resetGameVars();
            tiltSensitivityContainer.style.display = "flex";
            pauseBtn.hidden = false;
            resetDpadBtn.hidden = true;
            dpadContainer.style.display = "none";
            minSpeed = 40;
            currentSpeed = 120;
            resetDpadBtn.style.display = "none";
            window.addEventListener('deviceorientation', deviceTiltHandler);
            isPaused = false; hidePausedOverlay();
            gameStarted = true;
            accelerationStep = KEYBOARD_ACCEL;
            lastFrameTime = performance.now();
            animationFrameId = requestAnimationFrame(gameLoop);
            // Fallback: if tilt not ready in 3 s, switch to D-Pad mode
            setTimeout(() => {
                if (!tiltReady && tiltMode) {
                    window.removeEventListener('deviceorientation', deviceTiltHandler);
                    startGameWithDpad();
                }
            }, 3000);
        }
        function startGameWithDpad() {
            tiltMode = false; useTilt = false; useDpad = true;
            resetGameVars();
            tiltSensitivityContainer.style.display = "none";
            pauseBtn.hidden = false;
            resetDpadBtn.hidden = true;
            dpadContainer.style.display = "block";
            minSpeed = 40;
            currentSpeed = 120;
            resetDpadBtn.style.display = "none";
            isPaused = false; hidePausedOverlay();
            gameStarted = true;
            accelerationStep = DPAD_ACCEL;
            lastFrameTime = performance.now();
            animationFrameId = requestAnimationFrame(gameLoop);
        }
        function startGameWithKeyboard() {
            resetGameVars();
            tiltSensitivityContainer.style.display = "none";
            pauseBtn.hidden = true;
            resetDpadBtn.hidden = true;
            dpadContainer.style.display = "none";
            minSpeed = 25;
            currentSpeed = 100;
            resetDpadBtn.style.display = "none";
            isPaused = false; hidePausedOverlay();
            gameStarted = true;
            accelerationStep = KEYBOARD_ACCEL;
            lastFrameTime = performance.now();
            animationFrameId = requestAnimationFrame(gameLoop);
        }

        // --- D-Pad logic ---
        function setupDpad() {
            pauseBtn.hidden = false;
            resetDpadBtn.hidden = true;
            dpadContainer.style.display = "block";
            resetDpadBtn.style.display = "none";
            if (!dpadListenersAdded) addDpadListeners();
            startGameWithDpad();
        }
        // Remove D-pad placement logic and overlay
        // resetDpadBtn.onclick = function () {};
        // --- D-Pad Button Handlers ---
        // ["up", "down", "left", "right"].forEach(dir => {
        //     let btn = document.getElementById('dpad-' + dir);
        //     btn.addEventListener('touchstart', e => { e.preventDefault(); dpadPress(dir); }, { passive: false });
        //     btn.addEventListener('mousedown', e => { e.preventDefault(); dpadPress(dir); });
        //     btn.addEventListener('touchend', e => { e.preventDefault(); dpadRelease(dir); }, { passive: false });
        //     btn.addEventListener('mouseup', e => { e.preventDefault(); dpadRelease(dir); });
        //     btn.addEventListener('mouseleave', e => { dpadRelease(dir); });
        // });
        function addDpadListeners() {
            ["up", "down", "left", "right"].forEach(dir => {
                let btn = document.getElementById('dpad-' + dir);
                // Remove previous listeners by replacing the button node
                let newBtn = btn.cloneNode(true);
                btn.parentNode.replaceChild(newBtn, btn);

                newBtn.addEventListener('touchstart', e => { e.preventDefault(); dpadPress(dir); }, { passive: false });
                newBtn.addEventListener('mousedown', e => { e.preventDefault(); dpadPress(dir); });
                newBtn.addEventListener('touchend', e => { e.preventDefault(); dpadRelease(dir); }, { passive: false });
                newBtn.addEventListener('mouseup', e => { e.preventDefault(); dpadRelease(dir); });
                newBtn.addEventListener('mouseleave', e => { dpadRelease(dir); });
                newBtn.addEventListener('touchcancel', e => { dpadRelease(dir); });
                newBtn.addEventListener('pointercancel', e => { dpadRelease(dir); });
            });
            dpadListenersAdded = true;
        }
        function dpadPress(direction) {
            if (dpadPlacementMode) return;
            if (direction !== nextDirection && !isOppositeDirection(direction, nextDirection)) {
                nextDirection = direction;
            }
            dpadDirection = direction;
            dpadHoldStart = Date.now();
            dpadHolding = true;
            holdingKey = true;
            heldDirection = direction;
        }
        function dpadRelease(direction) {
            dpadHolding = false;
            holdingKey = false;
            heldDirection = null;
        }

        // --- Tap Key Controls for Desktop ---
        function tapKeydownHandler(e) {
            let pressed = false;
            switch (e.key) {
                case 'ArrowUp': case 'w': case 'W':
                    if (direction !== 'down') { nextDirection = 'up'; pressed = true; }
                    break;
                case 'ArrowDown': case 's': case 'S':
                    if (direction !== 'up') { nextDirection = 'down'; pressed = true; }
                    break;
                case 'ArrowLeft': case 'a': case 'A':
                    if (direction !== 'right') { nextDirection = 'left'; pressed = true; }
                    break;
                case 'ArrowRight': case 'd': case 'D':
                    if (direction !== 'left') { nextDirection = 'right'; pressed = true; }
                    break;
                case ' ':
                    togglePause();
                    break;
            }
            if (pressed) {
                holdingKey = true;
                heldDirection = nextDirection;
            } else if (
                (e.key === 'ArrowUp' && direction === 'down') ||
                (e.key === 'w' && direction === 'down') ||
                (e.key === 'ArrowDown' && direction === 'up') ||
                (e.key === 's' && direction === 'up') ||
                (e.key === 'ArrowLeft' && direction === 'right') ||
                (e.key === 'a' && direction === 'right') ||
                (e.key === 'ArrowRight' && direction === 'left') ||
                (e.key === 'd' && direction === 'left')
            ) {
                holdingKey = true;
                heldDirection = {
                    'ArrowUp': 'up', 'w': 'up', 'W': 'up',
                    'ArrowDown': 'down', 's': 'down', 'S': 'down',
                    'ArrowLeft': 'left', 'a': 'left', 'A': 'left',
                    'ArrowRight': 'right', 'd': 'right', 'D': 'right'
                }[e.key];
            }
        }
        function tapKeyupHandler(e) {
            if (
                (e.key === 'ArrowUp' && heldDirection === 'up') ||
                ((e.key === 'w' || e.key === 'W') && heldDirection === 'up') ||
                (e.key === 'ArrowDown' && heldDirection === 'down') ||
                ((e.key === 's' || e.key === 'S') && heldDirection === 'down') ||
                (e.key === 'ArrowLeft' && heldDirection === 'left') ||
                ((e.key === 'a' || e.key === 'A') && heldDirection === 'left') ||
                (e.key === 'ArrowRight' && heldDirection === 'right') ||
                ((e.key === 'd' || e.key === 'D') && heldDirection === 'right')
            ) {
                holdingKey = false;
                heldDirection = null;
            }
        }


        /* ----- Revised tilt pipeline (orientation‑aware, smoothed) ----- */

        function axesFromEvent(e) {
            const angle = screen.orientation?.angle || window.orientation || 0;
            switch (angle) {
                case 90: return { x: e.beta, y: -e.gamma };   // rotated right
                case 270: return { x: -e.beta, y: e.gamma };   // rotated left
                default: return { x: e.gamma, y: e.beta };   // portrait
            }
        }

        /* just store raw axes; smoothing happens per‑frame */
        function deviceTiltHandler(e) {
            if (!tiltMode || !tiltReady) return;
            rawTilt = axesFromEvent(e);
            tiltOK = true;
        }

        /* per‑frame smoothing + direction update */
        function tiltLoop() {
            if (tiltMode && tiltOK) {
                smoothTilt.x += FILTER * (rawTilt.x - smoothTilt.x);
                smoothTilt.y += FILTER * (rawTilt.y - smoothTilt.y);
                applyTilt(smoothTilt.x, smoothTilt.y);
            }
            requestAnimationFrame(tiltLoop);
        }
        requestAnimationFrame(tiltLoop);

        /* dominant‑axis 4‑way control + analogue power */
        function applyTilt(gamma, beta) {
            const dx = gamma, dy = beta;
            const ax = Math.abs(dx), ay = Math.abs(dy);

            if (ax < DEAD && ay < DEAD) {
                holdingKey = false;
                heldDirection = null;
                tiltPower = 0;
                return;
            }

            if (ax > ay) {
                chooseDir(dx > 0 ? 'right' : 'left', ax);
            } else {
                chooseDir(dy > 0 ? 'down' : 'up', ay);
            }
        }

        function chooseDir(dir, mag) {
            tiltPower = Math.min(1, (mag - DEAD) / (ACT - DEAD));
            if (tiltPower < 0) tiltPower = 0;

            nextDirection = dir;
            holdingKey = true;
            heldDirection = dir;
        }

        // --- PAUSE FEATURE ---
        function togglePause() {
            if (!gameStarted) return;
            isPaused = !isPaused;
            if (isPaused) showPausedOverlay();
            else { hidePausedOverlay(); draw(); }
        }
        function resumeGame() {
            if (isPaused) {
                isPaused = false;
                hidePausedOverlay();
                draw();
            }
        }
        function showPausedOverlay() {
            pausedOverlay.style.display = "flex";
            document.getElementById('paused-title').textContent = "Paused";
            document.getElementById('paused-score-container').style.display = "block";
            let mainBtn = document.getElementById('overlay-main-btn');
            let newMainBtn = mainBtn.cloneNode(true);
            mainBtn.parentNode.replaceChild(newMainBtn, mainBtn);
            newMainBtn.textContent = "Resume";
            newMainBtn.onclick = resumeGame;
            // Secondary "Restart" button logic
            let secondaryBtn = document.getElementById('overlay-secondary-btn');
            let newSecBtn = secondaryBtn.cloneNode(true);
            secondaryBtn.parentNode.replaceChild(newSecBtn, secondaryBtn);
            newSecBtn.style.display = "inline-block";
            newSecBtn.textContent = "Restart";
            newSecBtn.onclick = restartGame;
            document.getElementById('paused-score-value').textContent = score;
            let darkBtn = document.getElementById('overlay-dark-btn');
            let newDarkBtn = darkBtn.cloneNode(true);
            darkBtn.parentNode.replaceChild(newDarkBtn, darkBtn);
            newDarkBtn.onclick = () => darkModeBtn.click();
            darkModeBtn.style.zIndex = 4000;
            if (pauseBtn) pauseBtn.hidden = false;
        }

        function showGameOverOverlay() {
            pausedOverlay.style.display = "flex";
            document.getElementById('paused-title').textContent = "Game Over";
            document.getElementById('paused-score-container').style.display = "block";
            let mainBtn = document.getElementById('overlay-main-btn');
            let newMainBtn = mainBtn.cloneNode(true);
            mainBtn.parentNode.replaceChild(newMainBtn, mainBtn);
            newMainBtn.textContent = "Restart";
            newMainBtn.onclick = restartGame;
            let secondaryBtn = document.getElementById('overlay-secondary-btn');
            let newSecBtn = secondaryBtn.cloneNode(true);
            secondaryBtn.parentNode.replaceChild(newSecBtn, secondaryBtn);
            newSecBtn.style.display = "none";
            document.getElementById('paused-score-value').textContent = score;
            let darkBtn = document.getElementById('overlay-dark-btn');
            let newDarkBtn = darkBtn.cloneNode(true);
            darkBtn.parentNode.replaceChild(newDarkBtn, darkBtn);
            newDarkBtn.onclick = () => darkModeBtn.click();
            darkModeBtn.style.zIndex = 4000;
            if (pauseBtn) pauseBtn.hidden = true;
        }
        function hidePausedOverlay() {
            pausedOverlay.style.display = "none";
            darkModeBtn.style.zIndex = 201;
        }
        pauseBtn.onclick = togglePause;
        window.addEventListener('keydown', function (e) {
            if (e.key === 'Escape' || e.key === 'p' || e.key === 'P') togglePause();
        });
        // Support immediate pause on touch devices
        pauseBtn.addEventListener('touchstart', function (e) {
            e.preventDefault();
            togglePause();
        }, { passive: false });

        function normalizeAngle(a) {
            while (a <= -Math.PI) a += 2 * Math.PI;
            while (a > Math.PI) a -= 2 * Math.PI;
            return a;
        }
        function shortestAngleDiff(a, b) {
            let d = a - b;
            d = ((d + Math.PI) % (2 * Math.PI)) - Math.PI;
            return d;
        }

        // --- Main Game Loop ---
        // --- Smooth Animation Game Loop ---

        function gameLoop(now) {
            if (gameOverTriggered) { return; }
            let headAngle = dirToAngle(direction);
            let da = Math.atan2(Math.sin(headAngle - tunnelAngle), Math.cos(headAngle - tunnelAngle));

            let catchup = 0.19;
            if (Math.abs(da) > 0.9) catchup = 0.39;
            if (Math.abs(da) > 1.8) catchup = 0.64;

            tunnelAngle += da * catchup;

            if (Math.abs(da) < 0.04) tunnelAngle = headAngle;
            let delta = now - lastFrameTime;

            lastFrameTime = now;
            if (isPaused) { animationFrameId = requestAnimationFrame(gameLoop); return; }

            // Speed/acceleration logic
            const frameSpeedRatio = Math.max(
                0,
                Math.min(
                    1,
                    (getNormalSpeed(score) - currentSpeed) /
                    (getNormalSpeed(score) - minSpeed)
                )
            );
            let targetNormalSpeed = getNormalSpeed(score);
            if (holdingKey && heldDirection === direction && currentSpeed < targetNormalSpeed - 3) animState = "accelerating";
            else if (holdingKey && isOppositeDirection(heldDirection, direction) && currentSpeed > targetNormalSpeed + 3) animState = "braking";
            else animState = "normal";
            if (holdingKey && heldDirection === direction) {
                const accel = ACCEL_RATE * (tiltPower || 1);
                if (currentSpeed > minSpeed) {
                    currentSpeed -= accel;
                    if (currentSpeed < minSpeed) currentSpeed = minSpeed;
                }
            } else if (holdingKey && isOppositeDirection(heldDirection, direction)) {
                currentSpeed += decelerationStep * 2;
                if (currentSpeed > maxSlowSpeed) currentSpeed = maxSlowSpeed;
            } else {
                let targetNormalSpeed = getNormalSpeed(score);
                if (currentSpeed > targetNormalSpeed) {
                    currentSpeed -= decelerationStep;
                    if (currentSpeed < targetNormalSpeed) currentSpeed = targetNormalSpeed;
                } else if (currentSpeed < targetNormalSpeed) {
                    currentSpeed += decelerationStep;
                    if (currentSpeed > targetNormalSpeed) currentSpeed = targetNormalSpeed;
                }
            }
            // Arrow morphing logic
            let speedRatio = frameSpeedRatio;
            // Smoothly animate arrowMorph toward speedRatio at a slower pace for a more fluid morph
            let arrowMorphRate = (Math.abs(speedRatio - arrowMorph) > 0.18) ? 0.18 : 0.065;
            arrowMorph += (speedRatio - arrowMorph) * arrowMorphRate;

            // Calculate per-move duration from currentSpeed (ms per move)
            let moveStep = delta / currentSpeed;
            animProgress += moveStep;
            if (animProgress >= 1) {
                // Complete grid move
                animProgress = 0;
                moveSnakeGrid();
            }

            // Interpolate positions (with springy/elastic motion)
            for (let i = 0; i < snake.length; i++) {
                let seg = snake[i];
                let targetX = seg.prevX + (seg.x - seg.prevX) * animProgress;
                let targetY = seg.prevY + (seg.y - seg.prevY) * animProgress;
                // Springiness: segments "ease" toward their target
                if (i === 0) {
                    // Head: normal interpolation
                    seg.realX = targetX;
                    seg.realY = targetY;
                } else {
                    seg.realX += (targetX - seg.realX) * 0.27;
                    seg.realY += (targetY - seg.realY) * 0.27;
                }
            }

            // DRAW
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            updateAndDrawParticles(ctx);
            // Draw food
            ctx.save();
            ctx.shadowColor = '#ef4444aa'; ctx.shadowBlur = 7;
            ctx.beginPath();
            ctx.arc(food.x * gridSize + gridSize / 2, food.y * gridSize + gridSize / 2, gridSize / 2 - 1, 0, Math.PI * 2);
            ctx.closePath();
            ctx.fillStyle = '#fb7185';
            ctx.fill();
            ctx.restore();
            animTick++;
            if (animTick > 10000) animTick = 0;
            for (let i = 0; i < snake.length; i++) {
                ctx.save();
                let x = snake[i].realX * gridSize + gridSize / 2;
                let y = snake[i].realY * gridSize + gridSize / 2;
                let anticipate = 0;
                if (nextDirection !== direction) {
                    let anticipDir = nextDirection;
                    anticipate = Math.sin(animTick * 0.28) * gridSize * 0.15;
                    if (anticipDir === "left") x -= anticipate;
                    else if (anticipDir === "right") x += anticipate;
                    else if (anticipDir === "up") y -= anticipate;
                    else if (anticipDir === "down") y += anticipate;
                }
                // Segment sway/oscillation (for i > 0 only)
                if (i > 0) {
                    let speedRatio = Math.max(0, Math.min(1,
                        (getNormalSpeed(score) - currentSpeed) /
                        (getNormalSpeed(score) - minSpeed)
                    ));
                    let sway = Math.sin(animTick * 0.18 + i * 0.5) * gridSize * 0.12 * (1 + (typeof speedRatio !== "undefined" ? speedRatio : 0));
                    if (direction === "left" || direction === "right") y += sway;
                    else x += sway;
                }
                if (i === 0) {
                    // Always use morphing head, even when not accelerating.
                    // Pass in arrowMorph as the morph parameter for smooth continuous morph.
                    drawDynamicHead(ctx, x, y, direction, arrowMorph);
                    if (animState === "braking") {
                        drawBrakeWave(ctx, x, y, animTick);
                        drawPuffyHead(ctx, x, y);
                    }
                } else {
                    if (animState === "braking") {
                        ctx.shadowColor = "#fb7185bb";
                        ctx.shadowBlur = 8;
                        ctx.fillStyle = "#f59e42";
                        roundedRect(ctx, x - gridSize / 2, y - gridSize / 2, gridSize, gridSize, 6);
                        ctx.fill();
                    } else if (animState === "accelerating") {
                        ctx.save();
                        // Blend body color with trail color using arrowMorph for smooth transition
                        let color = lerpColor("#38bdf8", "#0ff2fd", arrowMorph);
                        ctx.fillStyle = color;
                        ctx.shadowColor = "#0ea5e9bb";
                        ctx.shadowBlur = 8;
                        // Gradually decrease width as speed increases
                        let speedRatio = frameSpeedRatio;
                        // width goes from normal (1.0) to skinny (0.36) as speed increases
                        const widthFactor = 1 - 0.64 * frameSpeedRatio;
                        let w, h;
                        if (direction === "left" || direction === "right") {
                            w = gridSize * 0.94;
                            h = gridSize * widthFactor;
                        } else {
                            w = gridSize * widthFactor;
                            h = gridSize * 0.94;
                        }
                        roundedRect(ctx, x - w / 2, y - h / 2, w, h, 8);
                        ctx.fill();
                        ctx.restore();
                    } else {
                        ctx.shadowColor = "#a5f3fc66";
                        ctx.shadowBlur = 6;
                        ctx.fillStyle = "#38bdf8";
                        roundedRect(ctx, x - gridSize / 2, y - gridSize / 2, gridSize, gridSize, 3);
                        ctx.fill();
                    }
                }
                ctx.restore();
            }
            scoreBar.innerHTML = `Score: <span style="color:#06b6d4">${score}</span>`;
            updateSpeedBar(animState, currentSpeed, getNormalSpeed(score), minSpeed, maxSlowSpeed);

            animationFrameId = requestAnimationFrame(gameLoop);
        }
        function lerpColor(a, b, t) {
            // a, b are hex colors like "#0ea5e9"
            let ah = a.replace('#', ''), bh = b.replace('#', '');
            let ar = parseInt(ah.substr(0, 2), 16), ag = parseInt(ah.substr(2, 2), 16), ab = parseInt(ah.substr(4, 2), 16);
            let br = parseInt(bh.substr(0, 2), 16), bg = parseInt(bh.substr(2, 2), 16), bb = parseInt(bh.substr(4, 2), 16);
            let r = Math.round(ar + (br - ar) * t);
            let g = Math.round(ag + (bg - ag) * t);
            let b2 = Math.round(ab + (bb - ab) * t);
            return `rgb(${r},${g},${b2})`;
        }

        function drawDynamicHead(ctx, x, y, direction, morph) {
            // morph: 0 = fully square, 1 = fully arrow
            ctx.save();

            // Parameters for shape
            let baseLen = gridSize;
            let tipLen = gridSize * (1.0 + 1.7 * morph); // arrow tip extension
            let widthRear = gridSize * (1.05 - 0.25 * morph); // rear width
            let widthTip = gridSize * (1.05 - 0.70 * morph); // tip width narrows
            let cornerRadius = Math.max(0, gridSize * (0.25 - 0.23 * morph)); // corners go sharp

            // Color transition
            let color = lerpColor("#0ea5e9", "#0ff2fd", morph);

            // Outline color: blend from soft blue to neon as morph increases
            let outlineColor = lerpColor("#38bdf8", "#22d3ee", morph);
            // Shadow: off at morph 0, strong at morph 1
            let shadowAlpha = 0.07 + 0.43 * morph;
            ctx.shadowColor = `rgba(14, 165, 233, ${shadowAlpha.toFixed(2)})`;
            ctx.shadowBlur = 8 + 26 * morph;
            ctx.strokeStyle = outlineColor;
            ctx.lineWidth = 2.1 + 2.5 * morph;

            // Calculate points for shape
            let tipOffset = morph * gridSize * 0.4;
            let pts = [];
            if (direction === "right") {
                pts = [
                    [x - baseLen / 2, y - widthRear / 2], // rear left
                    [x - baseLen / 2, y + widthRear / 2], // rear right
                    [x + tipLen / 2, y + widthTip / 2],   // tip right
                    [x + tipLen / 2 + tipOffset, y],      // tip
                    [x + tipLen / 2, y - widthTip / 2]    // tip left
                ];
            } else if (direction === "left") {
                pts = [
                    [x + baseLen / 2, y + widthRear / 2],
                    [x + baseLen / 2, y - widthRear / 2],
                    [x - tipLen / 2, y - widthTip / 2],
                    [x - tipLen / 2 - tipOffset, y],
                    [x - tipLen / 2, y + widthTip / 2]
                ];
            } else if (direction === "up") {
                pts = [
                    [x - widthRear / 2, y + baseLen / 2],
                    [x + widthRear / 2, y + baseLen / 2],
                    [x + widthTip / 2, y - tipLen / 2],
                    [x, y - tipLen / 2 - tipOffset],
                    [x - widthTip / 2, y - tipLen / 2]
                ];
            } else { // down
                pts = [
                    [x + widthRear / 2, y - baseLen / 2],
                    [x - widthRear / 2, y - baseLen / 2],
                    [x - widthTip / 2, y + tipLen / 2],
                    [x, y + tipLen / 2 + tipOffset],
                    [x + widthTip / 2, y + tipLen / 2]
                ];
            }

            ctx.beginPath();
            ctx.moveTo(pts[0][0], pts[0][1]);
            if (cornerRadius > 0.5) {
                ctx.arcTo(
                    pts[1][0], pts[1][1],
                    pts[2][0], pts[2][1],
                    cornerRadius
                );
            } else {
                ctx.lineTo(pts[1][0], pts[1][1]);
            }
            ctx.lineTo(pts[2][0], pts[2][1]);
            ctx.lineTo(pts[3][0], pts[3][1]);
            ctx.lineTo(pts[4][0], pts[4][1]);
            if (cornerRadius > 0.5) {
                ctx.arcTo(
                    pts[0][0], pts[0][1],
                    pts[0][0], pts[0][1],
                    cornerRadius
                );
            } else {
                ctx.lineTo(pts[0][0], pts[0][1]);
            }
            ctx.closePath();
            ctx.fillStyle = color;
            ctx.fill();
            ctx.stroke();
            ctx.restore();
        }
        function drawSpeedStreaks(ctx, x, y, direction, speedRatio) {
            if (speedRatio < 0.03) return;
            ctx.save();
            let n = Math.floor(3 + 5 * speedRatio);
            let maxLen = gridSize * (0.5 + 1.2 * speedRatio);
            let baseA = 0.35 + 0.25 * speedRatio;
            let offsetP = gridSize * 0.22;

            for (let i = 0; i < n; i++) {
                let frac = i / n;
                let len = maxLen * (1 - frac * 0.38);
                let alpha = baseA * (1 - frac * 0.75);
                ctx.beginPath();
                ctx.strokeStyle = `rgba(14,165,233,${alpha.toFixed(2)})`;
                ctx.lineWidth = 2.3 - frac * 1.6;

                let x1 = x, y1 = y, x2 = x, y2 = y;
                if (direction === 'right') {
                    x1 -= gridSize / 2 + len; y1 -= offsetP * (frac - 0.5);
                    x2 -= gridSize / 2 + 2; y2 -= offsetP * (frac - 0.5);
                } else if (direction === 'left') {
                    x1 += gridSize / 2 + len; y1 -= offsetP * (frac - 0.5);
                    x2 += gridSize / 2 + 2; y2 -= offsetP * (frac - 0.5);
                } else if (direction === 'up') {
                    x1 -= offsetP * (frac - 0.5); y1 += gridSize / 2 + len;
                    x2 -= offsetP * (frac - 0.5); y2 += gridSize / 2 + 2;
                } else {
                    x1 -= offsetP * (frac - 0.5); y1 -= gridSize / 2 + len;
                    x2 -= offsetP * (frac - 0.5); y2 -= gridSize / 2 + 2;
                }
                ctx.moveTo(x1, y1);
                ctx.lineTo(x2, y2);
                ctx.stroke();
            }
            ctx.restore();
        }
        // Move snake on the grid, update prevX/prevY for smooth anim
        function moveSnakeGrid() {
            // Move body segments
            for (let i = snake.length - 1; i > 0; i--) {
                snake[i].prevX = snake[i].x;
                snake[i].prevY = snake[i].y;
                snake[i].x = snake[i - 1].x;
                snake[i].y = snake[i - 1].y;
            }
            // Move head
            let head = snake[0];
            head.prevX = head.x;
            head.prevY = head.y;
            direction = nextDirection;
            lastDrawDirection = direction;   // keep streak origin in sync with actual movement
            switch (direction) {
                case 'up': head.y--; break;
                case 'down': head.y++; break;
                case 'left': head.x--; break;
                case 'right': head.x++; break;
            }
            // COLLISION
            let bodySegments = snake.slice(1);
            // If not eating food this step, ignore the last segment (tail will move away)
            if (!(head.x === food.x && head.y === food.y)) {
                bodySegments = snake.slice(1, -1);
            }
            if (
                !gameOverTriggered &&
                (head.x < 0 || head.x >= tileCount || head.y < 0 || head.y >= tileCount
                    || bodySegments.some(seg => seg.x === head.x && seg.y === head.y))
            ) {
                gameOver();
                return;
            }
            // FOOD
            if (head.x === food.x && head.y === food.y) {
                score++;
                let tail = snake[snake.length - 1];
                snake.push({
                    x: tail.x, y: tail.y,
                    prevX: tail.x, prevY: tail.y,
                    realX: tail.realX, realY: tail.realY
                });
                food = getNewFoodPosition();
                let fx = food.x * gridSize + gridSize / 2, fy = food.y * gridSize + gridSize / 2;
                spawnParticles(fx, fy, "#fb7185", 20, 3.4, 1.5);
            }
        }
        function drawPointyHead(ctx, x, y, direction) {
            ctx.save(); ctx.shadowColor = "#06b6d4"; ctx.shadowBlur = 22;
            ctx.fillStyle = "#0ea5e9"; ctx.strokeStyle = "#22d3ee"; ctx.lineWidth = 2;
            let len = gridSize * 1.8, w = gridSize * 1.05, base = gridSize * 0.7;
            ctx.beginPath();
            if (direction === 'right') { ctx.moveTo(x + len / 2, y); ctx.lineTo(x - base / 2, y - w / 2); ctx.lineTo(x - base / 2, y + w / 2); }
            else if (direction === 'left') { ctx.moveTo(x - len / 2, y); ctx.lineTo(x + base / 2, y - w / 2); ctx.lineTo(x + base / 2, y + w / 2); }
            else if (direction === 'up') { ctx.moveTo(x, y - len / 2); ctx.lineTo(x - w / 2, y + base / 2); ctx.lineTo(x + w / 2, y + base / 2); }
            else if (direction === 'down') { ctx.moveTo(x, y + len / 2); ctx.lineTo(x - w / 2, y - base / 2); ctx.lineTo(x + w / 2, y - base / 2); }
            ctx.closePath(); ctx.fill(); ctx.stroke(); ctx.restore();
        }
        function drawSpeedLines(ctx, x, y, direction, tick) {
            ctx.save(); ctx.globalAlpha = 0.42; ctx.strokeStyle = "#0ea5e9"; ctx.lineWidth = 2.7;
            let spacing = 6, lines = 4, offset = Math.sin(tick * 0.25) * 2;
            for (let i = 0; i < lines; i++) {
                let factor = i - (lines - 1) / 2;
                if (direction === 'right') { ctx.beginPath(); ctx.moveTo(x - 14, y + factor * spacing + offset); ctx.lineTo(x - 25, y + factor * spacing + offset); ctx.stroke(); }
                else if (direction === 'left') { ctx.beginPath(); ctx.moveTo(x + 14, y + factor * spacing + offset); ctx.lineTo(x + 25, y + factor * spacing + offset); ctx.stroke(); }
                else if (direction === 'up') { ctx.beginPath(); ctx.moveTo(x + factor * spacing + offset, y + 14); ctx.lineTo(x + factor * spacing + offset, y + 25); ctx.stroke(); }
                else if (direction === 'down') { ctx.beginPath(); ctx.moveTo(x + factor * spacing + offset, y - 14); ctx.lineTo(x + factor * spacing + offset, y - 25); ctx.stroke(); }
            }
            ctx.globalAlpha = 1; ctx.restore();
        }
        function drawPuffyHead(ctx, x, y) {
            ctx.save(); ctx.shadowColor = "#fb7185"; ctx.shadowBlur = 20; ctx.fillStyle = "#f59e42";
            ctx.beginPath(); ctx.arc(x, y, gridSize * 0.87 + Math.sin(animTick * 0.20) * 2, 0, Math.PI * 2); ctx.closePath(); ctx.fill(); ctx.restore();
        }
        function drawBrakeWave(ctx, x, y, tick) {
            ctx.save(); let baseR = gridSize * 1.1;
            for (let i = 0; i < 3; i++) {
                ctx.beginPath(); ctx.globalAlpha = 0.21 - i * 0.05; ctx.strokeStyle = "#fb7185"; ctx.lineWidth = 3 - i;
                let waveRadius = baseR + Math.abs(Math.sin(tick * 0.23 + i)) * (10 + i * 5);
                ctx.arc(x, y, waveRadius, 0, Math.PI * 2); ctx.stroke();
            }
            ctx.globalAlpha = 1; ctx.restore();
        }
        function updateSpeedBar(animState, currentSpeed, normalSpeed, minSpeed, maxSlowSpeed) {
            let val = 0;
            if (currentSpeed > normalSpeed) val = -Math.min((currentSpeed - normalSpeed) / (maxSlowSpeed - normalSpeed), 1);
            else if (currentSpeed < normalSpeed) val = Math.min((normalSpeed - currentSpeed) / (normalSpeed - minSpeed), 1);
            let bar = speedBar, barIndicator = speedBarIndicator;
            let px = ((val + 1) / 2) * bar.offsetWidth, width = bar.offsetWidth * 0.09 + Math.abs(val) * bar.offsetWidth * 0.4;
            px = Math.max(2, Math.min(bar.offsetWidth - width - 2, px - width / 2));
            let bg = "#93c5fd";
            if (animState === "accelerating") bg = "linear-gradient(90deg,#38bdf8 40%,#06b6d4 100%)";
            if (animState === "braking") bg = "linear-gradient(90deg,#fb7185 10%,#f43f5e 80%)";
            barIndicator.style.left = px + "px";
            barIndicator.style.width = width + "px";
            barIndicator.style.height = "100%";
            barIndicator.style.background = bg;
            barIndicator.style.boxShadow = (animState !== "normal") ? `0 0 16px 3px ${animState === "accelerating" ? "#06b6d4" : "#f43f5e"}99` : "none";
        }
        function getNewFoodPosition() {
            let pos;
            while (true) {
                pos = { x: Math.floor(Math.random() * tileCount), y: Math.floor(Math.random() * tileCount) };
                if (!snake.some(segment => segment.x === pos.x && segment.y === pos.y)) return pos;
            }
        }
        function gameOver() {
            if (gameOverTriggered) return;
            gameOverTriggered = true;
            // Cancel the previous animation frame if it exists
            if (animationFrameId !== null) {
                cancelAnimationFrame(animationFrameId);
                animationFrameId = null;
            }
            // Show the custom overlay instead of alert
            showGameOverOverlay();
        }
        function roundedRect(ctx, x, y, w, h, r) {
            ctx.beginPath();
            ctx.moveTo(x + r, y);
            ctx.lineTo(x + w - r, y);
            ctx.quadraticCurveTo(x + w, y, x + w, y + r);
            ctx.lineTo(x + w, y + h - r);
            ctx.quadraticCurveTo(x + w, y + h, x + w - r, y + h);
            ctx.lineTo(x + r, y + h);
            ctx.quadraticCurveTo(x, y + h, x, y + h - r);
            ctx.lineTo(x, y + r);
            ctx.quadraticCurveTo(x, y, x + r, y);
            ctx.closePath();
        }

        // Service Worker registration for PWA (optional, harmless if missing)
        if ('serviceWorker' in navigator) {
            window.addEventListener('load', function () {
                navigator.serviceWorker.register('./service-worker.js');
            });
        }

        // --- On Load ---
        window.onload = function () {
            fitCanvas();
            darkModeBtn.hidden = false;
            resetDpadBtn.style.display = "none";
            if (isTouchDevice()) {
                controlModal.style.display = "flex";
                pauseBtn.hidden = true;
                resetDpadBtn.hidden = true;
                resetDpadBtn.style.display = "none";
            } else {
                // Desktop: attach keyboard handlers, hide touch UI
                pauseBtn.hidden = true;
                pauseBtn.hidden = false;
                resetDpadBtn.hidden = true;
                dpadContainer.style.display = "none";
                resetDpadBtn.style.display = "none";
                document.addEventListener('keydown', tapKeydownHandler);
                document.addEventListener('keyup', tapKeyupHandler);
                showStartOverlayFn();
            }
            // Hide mobile browser address bar once the page loads
            setTimeout(() => {
                window.scrollTo(0, 1);
            }, 50);
        };

        // --- Dark Mode Toggle ---
        let dark = false;
        darkModeBtn.onclick = function () {
            dark = !dark;
            document.body.classList.toggle('dark-mode', dark);
            const moonIcon = document.getElementById('dark-mode-icon-moon');
            const sunIcon = document.getElementById('dark-mode-icon-sun');
            const sunRays = document.getElementById('dark-mode-rays');
            if (dark) {
                moonIcon.setAttribute('opacity', '0');
                sunIcon.setAttribute('opacity', '1');
                sunRays.setAttribute('opacity', '1');
            } else {
                moonIcon.setAttribute('opacity', '1');
                sunIcon.setAttribute('opacity', '0');
                sunRays.setAttribute('opacity', '0');
            }
        };

    </script>
</body>

</html>