<!DOCTYPE html>
<html lang="en">

<head>
    <link rel="manifest" href="manifest.json">
    <meta name="theme-color" content="#38bdf8">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="#38bdf8">
    <link rel="apple-touch-icon" href="icon-192.png">
    <meta charset="UTF-8">
    <meta name="viewport" content="width=400, initial-scale=1.0">
    <title>Modern Snake Game (Joystick + Tilt)</title>
    <style>
        body {
            background: linear-gradient(135deg, #e9e9f2 0%, #f6faff 100%);
            min-height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
            margin: 0;
        }

        .game-container {
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        #score-bar {
            font-family: 'Segoe UI', Arial, sans-serif;
            font-size: 1.3rem;
            font-weight: 600;
            color: #334155;
            margin-bottom: 10px;
            letter-spacing: 0.5px;
            background: #fff;
            padding: 8px 30px;
            border-radius: 22px;
            box-shadow: 0 2px 8px #93c5fd33;
            user-select: none;
        }

        #speed-bar-container {
            width: 410px;
            margin-bottom: 16px;
            margin-top: 2px;
            display: flex;
            flex-direction: column;
            align-items: center;
            font-family: 'Segoe UI', Arial, sans-serif;
        }

        #speed-bar-labels {
            width: 100%;
            display: flex;
            justify-content: space-between;
            font-size: 11px;
            color: #64748b;
            padding: 0 6px;
            box-sizing: border-box;
        }

        #speed-bar {
            width: 100%;
            height: 16px;
            background: #f3f4f6;
            border-radius: 8px;
            border: 2px solid #cbd5e1;
            box-shadow: 0 2px 8px #bae6fd66;
            position: relative;
            overflow: hidden;
            margin-bottom: 2px;
            margin-top: 3px;
        }

        #speed-bar-indicator {
            position: absolute;
            top: 0;
            bottom: 0;
            height: 100%;
            border-radius: 8px;
            transition: left 0.08s cubic-bezier(.4, 2, .7, 1), width 0.1s cubic-bezier(.4, 2, .7, 1), background 0.2s;
        }

        #control-modal {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.75);
            z-index: 20;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
        }

        #control-modal>div {
            background: #fff;
            padding: 30px 25px 20px 25px;
            border-radius: 20px;
            text-align: center;
            min-width: 250px;
            max-width: 94vw;
        }

        #control-modal button {
            font-size: 1em;
            padding: 10px 30px;
            margin: 8px 0;
            border-radius: 10px;
            border: none;
            background: #38bdf8;
            color: #fff;
            cursor: pointer;
            transition: background 0.16s;
        }

        #control-modal button:active {
            background: #0ea5e9;
        }

        #control-modal button:disabled {
            background: #ddd !important;
            color: #aaa !important;
            cursor: not-allowed;
        }

        #tilt-sensitivity-container {
            margin: 10px 0 0 0;
            padding: 10px;
            border-radius: 8px;
            background: #f6faff;
            box-shadow: 0 2px 10px #bae6fd33;
            display: none;
            align-items: center;
            justify-content: center;
            gap: 12px;
        }

        #tilt-sensitivity-bar {
            width: 150px;
        }

        canvas {
            background: #f8fafc;
            border: 4px solid #38bdf8;
            border-radius: 22px;
            box-shadow: 0 8px 32px #38bdf866, 0 0 0 2px #bae6fd88;
            display: block;
            margin-top: 16px;
            touch-action: none;
            -webkit-user-select: none;
            user-select: none;
        }

        #joystick-container {
            position: fixed;
            right: 18px;
            bottom: 30px;
            width: 92px;
            height: 92px;
            z-index: 99;
            display: none;
            touch-action: none;
            user-select: none;
        }

        #joystick-bg {
            width: 100%;
            height: 100%;
            background: rgba(148, 163, 184, 0.13);
            border: 2.5px solid #38bdf8;
            border-radius: 50%;
            position: absolute;
            left: 0;
            top: 0;
        }

        #joystick-knob {
            width: 46px;
            height: 46px;
            background: linear-gradient(135deg, #38bdf8 70%, #06b6d4 100%);
            border-radius: 50%;
            position: absolute;
            left: 23px;
            top: 23px;
            box-shadow: 0 2px 14px #38bdf866;
            transition: left 0.05s, top 0.05s;
            touch-action: none;
        }

        @media (max-width: 600px) {
            #score-bar {
                font-size: 1.1rem;
                padding: 8px 16px;
            }

            #speed-bar-container {
                width: 92vw;
                max-width: 390px;
                margin-bottom: 8px;
            }

            #speed-bar {
                width: 100%;
            }

            canvas#gameCanvas {
                width: 96vw !important;
                height: 96vw !important;
                max-width: 390px !important;
                max-height: 390px !important;
                min-width: 220px !important;
                min-height: 220px !important;
                margin-top: 10px;
            }

            #joystick-container {
                right: 10vw;
                bottom: 13vw;
                width: 76px;
                height: 76px;
                min-width: 64px;
                min-height: 64px;
            }
        }
    </style>
</head>

<body>
    <input type="checkbox" id="haptic-switch" switch style="display:none">
    <div class="game-container">
        <div id="score-bar">Score: 0</div>
        <div id="speed-bar-container">
            <div id="speed-bar-labels">
                <span style="color:#f43f5e">Braking</span>
                <span style="color:#64748b;">Normal</span>
                <span style="color:#06b6d4">Accelerating</span>
            </div>
            <div id="speed-bar">
                <div id="speed-bar-indicator"></div>
            </div>
        </div>
        <div id="tilt-sensitivity-container">
            <span>Motion Sensitivity</span>
            <input id="tilt-sensitivity-bar" type="range" min="5" max="35" value="12">
            <span id="tilt-sensitivity-value">12</span>
        </div>
        <canvas id="gameCanvas" width="400" height="400"
            style="max-width:96vw;max-height:96vw;min-width:220px;min-height:220px;"></canvas>
    </div>
    <div id="joystick-container">
        <div id="joystick-bg"></div>
        <div id="joystick-knob"></div>
    </div>
    <div id="joystick-place-overlay"
        style="display:none;position:fixed;left:0;top:0;width:100vw;height:100vh;background:rgba(0,0,0,0.45);z-index:120;align-items:center;justify-content:center;font-size:1.5em;font-family:sans-serif;color:white;text-align:center;">
        <div>Tap anywhere to place your joystick<br><span style="font-size:1em;opacity:.7;">(You can change this later
                in menu)</span></div>
    </div>
    <button id="reset-joystick-btn"
        style="display:none;position:fixed;right:12vw;bottom:12vw;z-index:130;padding:10px 16px;border-radius:8px;font-size:1em;background:#38bdf8;color:#fff;border:none;box-shadow:0 2px 8px #bae6fd88;">Reset
        Joystick</button>
    <!-- Control Modal -->
    <div id="control-modal">
        <div>
            <h2 style="margin:0 0 18px;font-size:1.5em;">Choose Control Mode</h2>
            <button id="tap-mode-btn">Touch/Arrow Keys</button><br>
            <button id="tilt-mode-btn">Tilt (iPhone/Android)</button>
            <div id="tilt-steps" style="display:none;margin-top:18px;">
                <div id="tilt-permission-step">
                    <button id="tilt-perm-btn">Enable Tilt</button>
                </div>
                <div id="tilt-calibrate-step" style="display:none;">
                    <div style="margin-bottom:7px;">
                        Hold your phone in comfortable play position.<br>
                        Then tap Calibrate.
                    </div>
                    <button id="calibrate-btn">Calibrate</button>
                </div>
            </div>
        </div>
    </div>
    <script>
        // --- Haptic Feedback Utilities ---
        function isIOS() {
            return /iP(hone|od|ad)/.test(navigator.userAgent);
        }
        function isiOS18OrLater() {
            return isIOS() && /OS 1[8-9](_\d+)?\s/.test(navigator.userAgent);
        }
        function triggerHapticFallback() {
            const cb = document.getElementById('haptic-switch');
            cb.checked = !cb.checked;
        }
        function hapticFeedback(duration) {
            if ('vibrate' in navigator) {
                navigator.vibrate(duration || 30);
            } else if (isiOS18OrLater()) {
                triggerHapticFallback();
            }
        }
        // --- Device and UI Elements ---
        function tiltIsSupported() {
            return typeof DeviceOrientationEvent !== "undefined" &&
                typeof DeviceOrientationEvent.requestPermission === "function";
        }
        let controlModal = document.getElementById("control-modal");
        let tapModeBtn = document.getElementById("tap-mode-btn");
        let tiltModeBtn = document.getElementById("tilt-mode-btn");
        let tiltSteps = document.getElementById("tilt-steps");
        let tiltPermBtn = document.getElementById("tilt-perm-btn");
        let tiltCalibrateStep = document.getElementById("tilt-calibrate-step");
        let calibrateBtn = document.getElementById("calibrate-btn");
        let tiltSensitivityContainer = document.getElementById("tilt-sensitivity-container");
        let tiltSensitivityBar = document.getElementById("tilt-sensitivity-bar");
        let tiltSensitivityValue = document.getElementById("tilt-sensitivity-value");
        // --- Game State ---
        let useTilt = false, tiltReady = false;
        let tiltSensitivity = 12;
        let baseGamma = 0, baseBeta = 0;
        let tiltGammaAvg = 0, tiltBetaAvg = 0;
        let smoothingFactor = 0.25;
        let gameStarted = false;
        // Joystick control variables
        const joystickContainer = document.getElementById('joystick-container');
        const joystickKnob = document.getElementById('joystick-knob');
        const joystickBg = document.getElementById('joystick-bg');
        let joyActive = false;
        let joyPos = { x: 46, y: 46 };
        let joyDir = null;
        let joySpeed = 1;
        let joyVibAccel = false, joyVibBrake = false;
        function isTouchDevice() {
            return 'ontouchstart' in window || navigator.maxTouchPoints > 0;
        }
        // Modal controls
        tapModeBtn.onclick = () => {
            controlModal.style.display = "none";
            setTimeout(() => { startGameWithTap(); }, 350);
        };
        tiltModeBtn.onclick = () => {
            if (tiltIsSupported()) {
                tiltSteps.style.display = "block";
                tiltPermBtn.onclick = requestTiltPermission;
            }
        };
        if (!tiltIsSupported()) {
            tiltModeBtn.disabled = true;
            tiltModeBtn.innerText = "Tilt (Not Supported)";
        }
        tiltSensitivityBar.oninput = function () {
            tiltSensitivity = Number(this.value);
            tiltSensitivityValue.innerText = tiltSensitivity;
        };
        // --- Tilt Permission and Calibration ---
        function requestTiltPermission() {
            DeviceOrientationEvent.requestPermission().then(response => {
                if (response === 'granted') {
                    tiltPermBtn.disabled = true;
                    tiltCalibrateStep.style.display = "block";
                    calibrateBtn.onclick = calibrateBaseOrientation;
                } else {
                    alert("Permission denied.");
                }
            }).catch(err => {
                alert("Permission error: " + err);
            });
        }
        function calibrateBaseOrientation() {
            function onceCalib(e) {
                baseGamma = e.gamma || 0;
                baseBeta = e.beta || 0;
                tiltGammaAvg = baseGamma;
                tiltBetaAvg = baseBeta;
                window.removeEventListener('deviceorientation', onceCalib);
                useTilt = true;
                tiltReady = true;
                tiltSensitivityContainer.style.display = "flex";
                controlModal.style.display = "none";
                setTimeout(() => { startGameWithTilt(); }, 350);
            }
            window.addEventListener('deviceorientation', onceCalib);
        }
        // --- Game Logic and Variables ---
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const scoreBar = document.getElementById('score-bar');
        const speedBar = document.getElementById('speed-bar');
        const speedBarIndicator = document.getElementById('speed-bar-indicator');
        const gridSize = 10;
        const tileCount = 40;
        let snake, direction, nextDirection, food, score;
        let holdingKey = false;
        let heldDirection = null;
        let minSpeed = 25;
        let maxSlowSpeed = 200;
        let currentSpeed = 100;
        let accelerationStep = 7;
        let decelerationStep = 6;
        let animationFrameId = null;
        let animState = "normal";
        let animTick = 0;
        let tiltMode = false;
        let lastTiltDir = null;
        function getNormalSpeed(score) {
            return Math.max(100 - Math.floor(score / 5) * 5, 45);
        }
        function isOppositeDirection(dir1, dir2) {
            return (
                (dir1 === 'left' && dir2 === 'right') ||
                (dir1 === 'right' && dir2 === 'left') ||
                (dir1 === 'up' && dir2 === 'down') ||
                (dir1 === 'down' && dir2 === 'up')
            );
        }
        function resetGameVars() {
            snake = [{ x: 10, y: 10 }];
            direction = 'right';
            nextDirection = 'right';
            food = getNewFoodPosition();
            score = 0;
            holdingKey = false;
            heldDirection = null;
            currentSpeed = getNormalSpeed(0);
            animState = "normal";
            animTick = 0;
            lastTiltDir = null;
        }
        function startGameWithTap() {
            tiltMode = false;
            resetGameVars();
            tiltSensitivityContainer.style.display = "none";
            if (!gameStarted) {
                document.addEventListener('keydown', tapKeydownHandler);
                document.addEventListener('keyup', tapKeyupHandler);
            }
            if (isTouchDevice()) {
                joystickContainer.style.display = 'block';
            } else {
                joystickContainer.style.display = 'none';
            }
            gameStarted = true;
            draw();
        }
        function startGameWithTilt() {
            tiltMode = true;
            resetGameVars();
            tiltSensitivityContainer.style.display = "flex";
            joystickContainer.style.display = "none";
            window.addEventListener('deviceorientation', deviceTiltHandler);
            gameStarted = true;
            draw();
        }
        // --- Tap Key Controls for Desktop ---
        function tapKeydownHandler(e) {
            let pressed = false;
            switch (e.key) {
                case 'ArrowUp': case 'w': case 'W':
                    if (direction !== 'down') {
                        nextDirection = 'up'; pressed = true;
                    }
                    break;
                case 'ArrowDown': case 's': case 'S':
                    if (direction !== 'up') {
                        nextDirection = 'down'; pressed = true;
                    }
                    break;
                case 'ArrowLeft': case 'a': case 'A':
                    if (direction !== 'right') {
                        nextDirection = 'left'; pressed = true;
                    }
                    break;
                case 'ArrowRight': case 'd': case 'D':
                    if (direction !== 'left') {
                        nextDirection = 'right'; pressed = true;
                    }
                    break;
            }
            if (pressed) {
                holdingKey = true;
                heldDirection = nextDirection;
            } else if (
                (e.key === 'ArrowUp' && direction === 'down') ||
                (e.key === 'w' && direction === 'down') ||
                (e.key === 'ArrowDown' && direction === 'up') ||
                (e.key === 's' && direction === 'up') ||
                (e.key === 'ArrowLeft' && direction === 'right') ||
                (e.key === 'a' && direction === 'right') ||
                (e.key === 'ArrowRight' && direction === 'left') ||
                (e.key === 'd' && direction === 'left')
            ) {
                holdingKey = true;
                heldDirection = {
                    'ArrowUp': 'up', 'w': 'up', 'W': 'up',
                    'ArrowDown': 'down', 's': 'down', 'S': 'down',
                    'ArrowLeft': 'left', 'a': 'left', 'A': 'left',
                    'ArrowRight': 'right', 'd': 'right', 'D': 'right'
                }[e.key];
            }
        }
        function tapKeyupHandler(e) {
            if (
                (e.key === 'ArrowUp' && heldDirection === 'up') ||
                ((e.key === 'w' || e.key === 'W') && heldDirection === 'up') ||
                (e.key === 'ArrowDown' && heldDirection === 'down') ||
                ((e.key === 's' || e.key === 'S') && heldDirection === 'down') ||
                (e.key === 'ArrowLeft' && heldDirection === 'left') ||
                ((e.key === 'a' || e.key === 'A') && heldDirection === 'left') ||
                (e.key === 'ArrowRight' && heldDirection === 'right') ||
                ((e.key === 'd' || e.key === 'D') && heldDirection === 'right')
            ) {
                holdingKey = false;
                heldDirection = null;
            }
        }
        // --- Tilt Handler (with smoothing and sensitivity) ---
        function deviceTiltHandler(e) {
            if (!tiltMode || !tiltReady) return;
            tiltGammaAvg = tiltGammaAvg * (1 - smoothingFactor) + (e.gamma || 0) * smoothingFactor;
            tiltBetaAvg = tiltBetaAvg * (1 - smoothingFactor) + (e.beta || 0) * smoothingFactor;
            let dx = tiltGammaAvg - baseGamma;
            let dy = tiltBetaAvg - baseBeta;
            let newDir = null;
            if (dx > tiltSensitivity && direction !== 'left' && lastTiltDir !== 'right') {
                newDir = 'right';
            } else if (dx < -tiltSensitivity && direction !== 'right' && lastTiltDir !== 'left') {
                newDir = 'left';
            } else if (dy > tiltSensitivity && direction !== 'up' && lastTiltDir !== 'down') {
                newDir = 'down';
            } else if (dy < -tiltSensitivity && direction !== 'down' && lastTiltDir !== 'up') {
                newDir = 'up';
            }
            if (newDir) {
                nextDirection = newDir;
                holdingKey = true;
                heldDirection = newDir;
                lastTiltDir = newDir;
            } else {
                if (
                    (direction === 'left' && dx > tiltSensitivity / 2) ||
                    (direction === 'right' && dx < -tiltSensitivity / 2) ||
                    (direction === 'up' && dy > tiltSensitivity / 2) ||
                    (direction === 'down' && dy < -tiltSensitivity / 2)
                ) {
                    holdingKey = true;
                    heldDirection = (direction === 'left' || direction === 'right') ? (dx > 0 ? 'right' : 'left') : (dy > 0 ? 'down' : 'up');
                } else {
                    holdingKey = false;
                    heldDirection = null;
                    lastTiltDir = null;
                }
            }
        }
        // Joystick input handling
        joystickKnob.addEventListener('touchstart', function (e) {
            e.preventDefault();
            joyActive = true;
        }, { passive: false });
        window.addEventListener('touchmove', function (e) {
            if (!joyActive) return;
            e.preventDefault();
            const rect = joystickContainer.getBoundingClientRect();
            const touch = e.touches[0];
            let x = touch.clientX - rect.left;
            let y = touch.clientY - rect.top;
            let dx = x - 46;
            let dy = y - 46;
            let dist = Math.sqrt(dx * dx + dy * dy);
            let maxDist = 38;
            if (dist > maxDist) {
                dx = dx * maxDist / dist;
                dy = dy * maxDist / dist;
                x = 46 + dx;
                y = 46 + dy;
            }
            joystickKnob.style.left = (x - 23) + "px";
            joystickKnob.style.top = (y - 23) + "px";
            joyPos = { x, y };
            let prevJoyDir = joyDir;
            if (Math.abs(dx) > Math.abs(dy)) {
                if (dx > 10) joyDir = 'right';
                else if (dx < -10) joyDir = 'left';
                else joyDir = null;
            } else {
                if (dy > 10) joyDir = 'down';
                else if (dy < -10) joyDir = 'up';
                else joyDir = null;
            }
            joySpeed = Math.min(Math.max(dist / maxDist, 0.2), 1.5);
            if (joyDir && isOppositeDirection(joyDir, direction)) {
                joySpeed = 0.7 - (dist / maxDist) * 0.5;
            }
            if (joyDir && joyDir !== direction && !isOppositeDirection(joyDir, direction)) {
                nextDirection = joyDir;
            }
            holdingKey = !!joyDir;
            heldDirection = joyDir;
            if (joySpeed > 1.2 && !joyVibAccel) {
                hapticFeedback(35);
                joyVibAccel = true;
                setTimeout(() => { joyVibAccel = false; }, 250);
            } else if (joySpeed < 0.8 && !joyVibBrake) {
                hapticFeedback([15, 25, 15]);
                joyVibBrake = true;
                setTimeout(() => { joyVibBrake = false; }, 300);
            }
        }, { passive: false });
        window.addEventListener('touchend', function (e) {
            joyActive = false;
            joystickKnob.style.left = "23px";
            joystickKnob.style.top = "23px";
            joyPos = { x: 46, y: 46 };
            joyDir = null;
            holdingKey = false;
            heldDirection = null;
            joySpeed = 1;
            joyVibAccel = false;
            joyVibBrake = false;
        }, { passive: false });
        // --- Main Game Loop ---
        function draw() {
            let targetNormalSpeed = getNormalSpeed(score);
            if (isTouchDevice() && joyActive && !tiltMode) {
                if (joyDir && heldDirection === direction) {
                    currentSpeed = Math.max(targetNormalSpeed * (1 - (joySpeed - 1)), 18);
                } else if (joyDir && isOppositeDirection(joyDir, direction)) {
                    currentSpeed = Math.min(targetNormalSpeed / Math.max(joySpeed, 0.6), 220);
                }
            }
            if (holdingKey && heldDirection === direction && currentSpeed < targetNormalSpeed - 3) {
                animState = "accelerating";
            } else if (holdingKey && isOppositeDirection(heldDirection, direction) && currentSpeed > targetNormalSpeed + 3) {
                animState = "braking";
            } else {
                animState = "normal";
            }
            if (holdingKey && heldDirection === direction) {
                currentSpeed -= accelerationStep;
                if (currentSpeed < minSpeed) currentSpeed = minSpeed;
            } else if (holdingKey && isOppositeDirection(heldDirection, direction)) {
                currentSpeed += decelerationStep * 2;
                if (currentSpeed > maxSlowSpeed) currentSpeed = maxSlowSpeed;
            } else {
                if (currentSpeed > targetNormalSpeed) {
                    currentSpeed -= decelerationStep;
                    if (currentSpeed < targetNormalSpeed) currentSpeed = targetNormalSpeed;
                } else if (currentSpeed < targetNormalSpeed) {
                    currentSpeed += decelerationStep;
                    if (currentSpeed > targetNormalSpeed) currentSpeed = targetNormalSpeed;
                }
            }
            direction = nextDirection;
            const head = { ...snake[0] };
            switch (direction) {
                case 'up': head.y--; break;
                case 'down': head.y++; break;
                case 'left': head.x--; break;
                case 'right': head.x++; break;
            }
            snake.unshift(head);
            if (head.x < 0 || head.x >= tileCount || head.y < 0 || head.y >= tileCount) {
                gameOver(); return;
            }
            if (snake.slice(1).some(segment => segment.x === head.x && segment.y === head.y)) {
                gameOver(); return;
            }
            if (head.x === food.x && head.y === food.y) {
                score++;
                food = getNewFoodPosition();
            } else {
                snake.pop();
            }
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            ctx.save();
            ctx.shadowColor = '#ef4444aa';
            ctx.shadowBlur = 7;
            ctx.beginPath();
            ctx.arc(food.x * gridSize + gridSize / 2, food.y * gridSize + gridSize / 2, gridSize / 2 - 1, 0, Math.PI * 2);
            ctx.closePath();
            ctx.fillStyle = '#fb7185';
            ctx.fill();
            ctx.restore();
            animTick++;
            if (animTick > 10000) animTick = 0;
            for (let i = 0; i < snake.length; i++) {
                ctx.save();
                if (i === 0) {
                    let x = snake[i].x * gridSize + gridSize / 2;
                    let y = snake[i].y * gridSize + gridSize / 2;
                    if (animState === "accelerating") {
                        drawSpeedLines(ctx, x, y, direction, animTick);
                        drawPointyHead(ctx, x, y, direction);
                    } else if (animState === "braking") {
                        drawBrakeWave(ctx, x, y, animTick);
                        drawPuffyHead(ctx, x, y);
                    } else {
                        ctx.shadowColor = "#22d3ee";
                        ctx.shadowBlur = 6;
                        ctx.fillStyle = "#0ea5e9";
                        roundedRect(ctx, x - gridSize / 2, y - gridSize / 2, gridSize, gridSize, 3.5);
                        ctx.fill();
                    }
                } else {
                    ctx.shadowColor = "#a5f3fc66";
                    ctx.shadowBlur = 6;
                    ctx.fillStyle = "#38bdf8";
                    const x = snake[i].x * gridSize;
                    const y = snake[i].y * gridSize;
                    roundedRect(ctx, x, y, gridSize, gridSize, 3);
                    ctx.fill();
                }
                ctx.restore();
            }
            scoreBar.innerHTML = `Score: <span style="color:#06b6d4">${score}</span>`;
            updateSpeedBar(animState, currentSpeed, getNormalSpeed(score), minSpeed, maxSlowSpeed);
            animationFrameId = setTimeout(() => requestAnimationFrame(draw), currentSpeed);
        }
        function drawPointyHead(ctx, x, y, direction) {
            ctx.save();
            ctx.shadowColor = "#06b6d4";
            ctx.shadowBlur = 22;
            ctx.fillStyle = "#0ea5e9";
            ctx.strokeStyle = "#22d3ee";
            ctx.lineWidth = 2;
            let len = gridSize * 1.8, w = gridSize * 1.05;
            let base = gridSize * 0.7;
            ctx.beginPath();
            if (direction === 'right') {
                ctx.moveTo(x + len / 2, y);
                ctx.lineTo(x - base / 2, y - w / 2);
                ctx.lineTo(x - base / 2, y + w / 2);
            } else if (direction === 'left') {
                ctx.moveTo(x - len / 2, y);
                ctx.lineTo(x + base / 2, y - w / 2);
                ctx.lineTo(x + base / 2, y + w / 2);
            } else if (direction === 'up') {
                ctx.moveTo(x, y - len / 2);
                ctx.lineTo(x - w / 2, y + base / 2);
                ctx.lineTo(x + w / 2, y + base / 2);
            } else if (direction === 'down') {
                ctx.moveTo(x, y + len / 2);
                ctx.lineTo(x - w / 2, y - base / 2);
                ctx.lineTo(x + w / 2, y - base / 2);
            }
            ctx.closePath();
            ctx.fill();
            ctx.stroke();
            ctx.restore();
        }
        function drawSpeedLines(ctx, x, y, direction, tick) {
            ctx.save();
            ctx.globalAlpha = 0.42;
            ctx.strokeStyle = "#0ea5e9";
            ctx.lineWidth = 2.7;
            let spacing = 6, lines = 4;
            let offset = Math.sin(tick * 0.25) * 2;
            for (let i = 0; i < lines; i++) {
                let factor = i - (lines - 1) / 2;
                if (direction === 'right') {
                    ctx.beginPath();
                    ctx.moveTo(x - 14, y + factor * spacing + offset);
                    ctx.lineTo(x - 25, y + factor * spacing + offset);
                    ctx.stroke();
                } else if (direction === 'left') {
                    ctx.beginPath();
                    ctx.moveTo(x + 14, y + factor * spacing + offset);
                    ctx.lineTo(x + 25, y + factor * spacing + offset);
                    ctx.stroke();
                } else if (direction === 'up') {
                    ctx.beginPath();
                    ctx.moveTo(x + factor * spacing + offset, y + 14);
                    ctx.lineTo(x + factor * spacing + offset, y + 25);
                    ctx.stroke();
                } else if (direction === 'down') {
                    ctx.beginPath();
                    ctx.moveTo(x + factor * spacing + offset, y - 14);
                    ctx.lineTo(x + factor * spacing + offset, y - 25);
                    ctx.stroke();
                }
            }
            ctx.globalAlpha = 1;
            ctx.restore();
        }
        function drawPuffyHead(ctx, x, y) {
            ctx.save();
            ctx.shadowColor = "#fb7185";
            ctx.shadowBlur = 20;
            ctx.fillStyle = "#f59e42";
            ctx.beginPath();
            ctx.arc(x, y, gridSize * 0.87 + Math.sin(animTick * 0.20) * 2, 0, Math.PI * 2);
            ctx.closePath();
            ctx.fill();
            ctx.restore();
        }
        function drawBrakeWave(ctx, x, y, tick) {
            ctx.save();
            let baseR = gridSize * 1.1;
            for (let i = 0; i < 3; i++) {
                ctx.beginPath();
                ctx.globalAlpha = 0.21 - i * 0.05;
                ctx.strokeStyle = "#fb7185";
                ctx.lineWidth = 3 - i;
                let waveRadius = baseR + Math.abs(Math.sin(tick * 0.23 + i)) * (10 + i * 5);
                ctx.arc(x, y, waveRadius, 0, Math.PI * 2);
                ctx.stroke();
            }
            ctx.globalAlpha = 1;
            ctx.restore();
        }
        function updateSpeedBar(animState, currentSpeed, normalSpeed, minSpeed, maxSlowSpeed) {
            let val = 0;
            if (currentSpeed > normalSpeed) {
                val = -Math.min((currentSpeed - normalSpeed) / (maxSlowSpeed - normalSpeed), 1);
            } else if (currentSpeed < normalSpeed) {
                val = Math.min((normalSpeed - currentSpeed) / (normalSpeed - minSpeed), 1);
            }
            let bar = speedBar;
            let barIndicator = speedBarIndicator;
            let px = ((val + 1) / 2) * bar.offsetWidth;
            let width = bar.offsetWidth * 0.09 + Math.abs(val) * bar.offsetWidth * 0.4;
            px = Math.max(2, Math.min(bar.offsetWidth - width - 2, px - width / 2));
            let bg = "#93c5fd";
            if (animState === "accelerating") bg = "linear-gradient(90deg,#38bdf8 40%,#06b6d4 100%)";
            if (animState === "braking") bg = "linear-gradient(90deg,#fb7185 10%,#f43f5e 80%)";
            barIndicator.style.left = px + "px";
            barIndicator.style.width = width + "px";
            barIndicator.style.height = "100%";
            barIndicator.style.background = bg;
            barIndicator.style.boxShadow = (animState !== "normal")
                ? `0 0 16px 3px ${animState === "accelerating" ? "#06b6d4" : "#f43f5e"}99`
                : "none";
        }
        function getNewFoodPosition() {
            let pos;
            while (true) {
                pos = {
                    x: Math.floor(Math.random() * tileCount),
                    y: Math.floor(Math.random() * tileCount)
                };
                if (!snake.some(segment => segment.x === pos.x && segment.y === pos.y)) {
                    return pos;
                }
            }
        }
        function gameOver() {
            clearTimeout(animationFrameId);
            setTimeout(() => {
                alert(`Game Over! Your score: ${score}`);
                resetGameVars();
                draw();
            }, 200);
        }
        function roundedRect(ctx, x, y, w, h, r) {
            ctx.beginPath();
            ctx.moveTo(x + r, y);
            ctx.lineTo(x + w - r, y);
            ctx.quadraticCurveTo(x + w, y, x + w, y + r);
            ctx.lineTo(x + w, y + h - r);
            ctx.quadraticCurveTo(x + w, y + h, x + w - r, y + h);
            ctx.lineTo(x + r, y + h);
            ctx.quadraticCurveTo(x, y + h, x, y + h - r);
            ctx.lineTo(x, y + r);
            ctx.quadraticCurveTo(x, y, x + r, y);
            ctx.closePath();
        }
        // Service Worker registration for PWA
        if ('serviceWorker' in navigator) {
            window.addEventListener('load', function () {
                navigator.serviceWorker.register('./service-worker.js');
            });
        }
        // --- Responsive Canvas Sizing ---
        function fitCanvas() {
            let size = Math.min(window.innerWidth * 0.96, window.innerHeight * 0.6, 400);
            canvas.style.width = size + "px";
            canvas.style.height = size + "px";
        }
        window.addEventListener("resize", fitCanvas);
        fitCanvas();
        // Joystick placement by tap (mobile)
        const joystickPlaceOverlay = document.getElementById('joystick-place-overlay');
        const resetJoystickBtn = document.getElementById('reset-joystick-btn');

        function setJoystickPos(x, y) {
            joystickContainer.style.left = x + 'px';
            joystickContainer.style.top = y + 'px';
            joystickContainer.style.right = '';
            joystickContainer.style.bottom = '';
            joystickContainer.style.position = 'fixed';
        }
        function showJoystickPlacement() {
            joystickPlaceOverlay.style.display = 'flex';
            joystickContainer.style.display = 'none';
            resetJoystickBtn.style.display = 'none';
        }
        function saveJoystickPos(x, y) {
            localStorage.setItem('joystickPos', JSON.stringify({ x, y }));
        }
        function restoreJoystickPos() {
            let joyPos = localStorage.getItem('joystickPos');
            if (joyPos) {
                let pos = JSON.parse(joyPos);
                setJoystickPos(pos.x, pos.y);
                joystickContainer.style.display = 'block';
                resetJoystickBtn.style.display = 'block';
            }
        }
        if (isTouchDevice()) {
            // If no position saved, ask for placement
            if (!localStorage.getItem('joystickPos')) {
                showJoystickPlacement();
            } else {
                restoreJoystickPos();
            }
            // Placement overlay tap
            joystickPlaceOverlay.addEventListener('touchstart', function (e) {
                e.preventDefault();
                const touch = e.touches[0];
                let x = touch.clientX - 46;
                let y = touch.clientY - 46;
                saveJoystickPos(x, y);
                setJoystickPos(x, y);
                joystickContainer.style.display = 'block';
                resetJoystickBtn.style.display = 'block';
                joystickPlaceOverlay.style.display = 'none';
            }, { once: false });
            // Reset joystick button
            resetJoystickBtn.addEventListener('click', function () {
                localStorage.removeItem('joystickPos');
                showJoystickPlacement();
            });
        }
    </script>
</body>

</html>