<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Snake Game (Responsive, D-Pad/Tilt)</title>
    <style>
        body {
            background: linear-gradient(135deg, #e9e9f2 0%, #f6faff 100%);
            min-height: 100vh;
            margin: 0;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
        }

        .game-container {
            width: 100vw;
            max-width: 100vw;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 2vw;
            box-sizing: border-box;
        }

        #score-bar {
            font-family: 'Segoe UI', Arial, sans-serif;
            font-size: 1.1rem;
            font-weight: 600;
            color: #334155;
            background: #fff;
            padding: 7px 18px;
            border-radius: 18px;
            margin-top: 2vw;
            margin-bottom: 1vw;
            box-shadow: 0 2px 8px #93c5fd33;
            user-select: none;
        }

        #speed-bar-container {
            width: 90vw;
            max-width: 400px;
            margin-bottom: 8px;
            display: flex;
            flex-direction: column;
            align-items: center;
            font-family: 'Segoe UI', Arial, sans-serif;
        }

        #speed-bar-labels {
            width: 100%;
            display: flex;
            justify-content: space-between;
            font-size: 11px;
            color: #64748b;
            padding: 0 6px;
            box-sizing: border-box;
        }

        #speed-bar {
            width: 100%;
            height: 16px;
            background: #f3f4f6;
            border-radius: 8px;
            border: 2px solid #cbd5e1;
            box-shadow: 0 2px 8px #bae6fd66;
            position: relative;
            overflow: hidden;
            margin-bottom: 2px;
            margin-top: 3px;
        }

        #speed-bar-indicator {
            position: absolute;
            top: 0;
            bottom: 0;
            height: 100%;
            border-radius: 8px;
        }

        #tilt-sensitivity-container {
            margin: 7px 0 0 0;
            padding: 7px;
            border-radius: 8px;
            background: #f6faff;
            box-shadow: 0 2px 10px #bae6fd33;
            display: none;
            align-items: center;
            justify-content: center;
            gap: 12px;
        }

        #tilt-sensitivity-bar {
            width: 120px;
        }

        canvas {
            background: #f8fafc;
            border: 4px solid #38bdf8;
            border-radius: 18px;
            box-shadow: 0 8px 32px #38bdf866, 0 0 0 2px #bae6fd88;
            display: block;
            margin-top: 10px;
            max-width: 98vw;
            max-height: 56vw;
            width: 98vw;
            height: auto;
            min-width: 110px;
            min-height: 110px;
            touch-action: none;
            -webkit-user-select: none;
            user-select: none;
        }

        #pause-btn,
        #reset-dpad-btn {
            position: fixed;
            top: 8px;
            z-index: 201;
            background: #fff;
            border: 2px solid #38bdf8;
            color: #0ea5e9;
            border-radius: 12px;
            font-size: 1.15em;
            width: 42px;
            height: 42px;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            box-shadow: 0 2px 8px #38bdf833;
            transition: background 0.14s, box-shadow 0.14s;
            font-family: 'Segoe UI', Arial, sans-serif;
            margin-left: 8px;
        }

        #pause-btn {
            right: 14px;
        }

        #reset-dpad-btn {
            right: 64px;
        }

        #pause-btn[hidden],
        #reset-dpad-btn[hidden] {
            display: none;
        }

        #paused-overlay {
            position: fixed;
            left: 0;
            top: 0;
            width: 100vw;
            height: 100vh;
            background: rgba(0, 0, 0, 0.32);
            z-index: 2002;
            display: none;
            align-items: center;
            justify-content: center;
        }

        #paused-overlay-inner {
            background: #fff;
            padding: 40px 32px 34px 32px;
            border-radius: 22px;
            font-size: 1.4em;
            color: #0ea5e9;
            font-family: 'Segoe UI', Arial, sans-serif;
            box-shadow: 0 6px 36px #38bdf833;
            text-align: center;
            min-width: 180px;
            max-width: 80vw;
        }

        #dpad-container {
            position: fixed;
            z-index: 210;
            display: none;
        }

        .dpad {
            width: 98px;
            height: 98px;
            background: rgba(56, 189, 248, 0.22);
            border-radius: 24px;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            box-shadow: 0 2px 16px #38bdf822;
            touch-action: none;
        }

        .dpad-row {
            display: flex;
            flex-direction: row;
            width: 100%;
            justify-content: center;
        }

        .dpad-btn {
            width: 42px;
            height: 42px;
            margin: 6px;
            border-radius: 13px;
            background: rgba(14, 165, 233, 0.73);
            color: #fff;
            font-size: 1.45em;
            border: none;
            display: flex;
            align-items: center;
            justify-content: center;
            box-shadow: 0 0 8px #bae6fd44;
            touch-action: none;
            transition: background 0.18s;
        }

        .dpad-btn:active {
            background: #38bdf8;
        }

        #dpad-placement-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            background: rgba(0, 0, 0, 0.32);
            z-index: 3000;
            display: none;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            font-family: 'Segoe UI', Arial, sans-serif;
        }

        #dpad-placement-message {
            color: #38bdf8;
            font-size: 2em;
            font-weight: bold;
            background: #fff;
            padding: 36px 32px;
            border-radius: 22px;
            box-shadow: 0 4px 32px #38bdf822;
            opacity: 0.95;
        }

        @media (max-width: 700px) {
            .game-container {
                gap: 2vw;
            }

            #score-bar {
                margin-bottom: 2vw;
            }

            #speed-bar-container {
                margin-bottom: 2vw;
            }

            canvas#gameCanvas {
                margin-top: 2vw;
                max-width: 98vw;
                max-height: 80vw;
                min-width: 110px;
                min-height: 110px;
            }

            #pause-btn,
            #reset-dpad-btn {
                width: 37px;
                height: 37px;
                font-size: 1em;
                top: 4px;
            }

            #pause-btn {
                right: 10px;
            }

            #reset-dpad-btn {
                right: 50px;
            }

            #tilt-sensitivity-bar {
                width: 80px;
            }
        }

        @media (min-width: 1024px) {

            #dpad-container,
            #reset-dpad-btn {
                display: none !important;
            }
        }
    </style>
</head>

<body>
    <button id="pause-btn" title="Pause/Resume" hidden>‚è∏Ô∏è</button>
    <button id="reset-dpad-btn" title="Reset D-Pad" hidden>üéØ</button>
    <div id="paused-overlay">
        <div id="paused-overlay-inner">
            <div style="font-size:1.2em;margin-bottom:10px;">‚è∏Ô∏è Game Paused</div>
            <button onclick="resumeGame()"
                style="font-size:1em;padding:10px 24px;border-radius:10px;background:#38bdf8;color:#fff;border:none;cursor:pointer;">Resume</button>
        </div>
    </div>
    <div id="dpad-placement-overlay">
        <div id="dpad-placement-message">Tap anywhere to place your D-pad</div>
    </div>
    <div id="dpad-container">
        <div class="dpad">
            <div class="dpad-row">
                <button class="dpad-btn" id="dpad-up">‚ñ≤</button>
            </div>
            <div class="dpad-row">
                <button class="dpad-btn" id="dpad-left">‚óÄ</button>
                <div style="width:10px;"></div>
                <button class="dpad-btn" id="dpad-right">‚ñ∂</button>
            </div>
            <div class="dpad-row">
                <button class="dpad-btn" id="dpad-down">‚ñº</button>
            </div>
        </div>
    </div>
    <input type="checkbox" id="haptic-switch" switch style="display:none">
    <div class="game-container">
        <div id="score-bar">Score: 0</div>
        <div id="speed-bar-container">
            <div id="speed-bar-labels">
                <span style="color:#f43f5e">Braking</span>
                <span style="color:#64748b;">Normal</span>
                <span style="color:#06b6d4">Accelerating</span>
            </div>
            <div id="speed-bar">
                <div id="speed-bar-indicator"></div>
            </div>
        </div>
        <div id="tilt-sensitivity-container">
            <span>Motion Sensitivity</span>
            <input id="tilt-sensitivity-bar" type="range" min="5" max="35" value="12">
            <span id="tilt-sensitivity-value">12</span>
        </div>
        <canvas id="gameCanvas" width="400" height="400"></canvas>
    </div>
    <div id="control-modal"
        style="display:none;position:fixed;left:0;top:0;width:100vw;height:100vh;background:rgba(0,0,0,0.7);z-index:5000;align-items:center;justify-content:center;">
        <div
            style="background:#fff;padding:26px 18px 18px 18px;border-radius:22px;text-align:center;min-width:180px;max-width:92vw;">
            <h2 style="margin:0 0 12px;font-size:1.15em;">Choose Control Mode</h2>
            <button id="dpad-mode-btn"
                style="margin-bottom:8px;padding:8px 25px;border-radius:8px;border:none;background:#38bdf8;color:#fff;cursor:pointer;font-size:1.07em;">Touch
                D-Pad</button><br>
            <button id="tilt-mode-btn"
                style="padding:8px 25px;border-radius:8px;border:none;background:#06b6d4;color:#fff;cursor:pointer;font-size:1.07em;">Tilt
                (iPhone/Android)</button>
            <div id="tilt-steps" style="display:none;margin-top:12px;">
                <div id="tilt-permission-step">
                    <button id="tilt-perm-btn">Enable Tilt</button>
                </div>
                <div id="tilt-calibrate-step" style="display:none;">
                    <div style="margin-bottom:7px;">
                        Hold your phone in comfortable play position.<br>
                        Then tap Calibrate.
                    </div>
                    <button id="calibrate-btn">Calibrate</button>
                </div>
            </div>
        </div>
    </div>
    <script>
        // Helper functions
        function isIOS() { return /iP(hone|od|ad)/.test(navigator.userAgent); }
        function isiOS18OrLater() { return isIOS() && /OS 1[8-9](_\d+)?\s/.test(navigator.userAgent); }
        function isTouchDevice() { return 'ontouchstart' in window || navigator.maxTouchPoints > 0; }
        function triggerHapticFallback() {
            const cb = document.getElementById('haptic-switch');
            cb.checked = !cb.checked;
        }
        function hapticFeedback(duration) {
            if ('vibrate' in navigator) navigator.vibrate(duration || 30);
            else if (isiOS18OrLater()) triggerHapticFallback();
        }

        // UI element references
        const controlModal = document.getElementById("control-modal");
        const dpadModeBtn = document.getElementById("dpad-mode-btn");
        const tiltModeBtn = document.getElementById("tilt-mode-btn");
        const tiltSteps = document.getElementById("tilt-steps");
        const tiltPermBtn = document.getElementById("tilt-perm-btn");
        const tiltCalibrateStep = document.getElementById("tilt-calibrate-step");
        const calibrateBtn = document.getElementById("calibrate-btn");
        const tiltSensitivityContainer = document.getElementById("tilt-sensitivity-container");
        const tiltSensitivityBar = document.getElementById("tilt-sensitivity-bar");
        const tiltSensitivityValue = document.getElementById("tilt-sensitivity-value");
        const pauseBtn = document.getElementById("pause-btn");
        const pausedOverlay = document.getElementById("paused-overlay");
        const dpadContainer = document.getElementById("dpad-container");
        const resetDpadBtn = document.getElementById("reset-dpad-btn");
        const dpadPlacementOverlay = document.getElementById("dpad-placement-overlay");
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const scoreBar = document.getElementById('score-bar');
        const speedBar = document.getElementById('speed-bar');
        const speedBarIndicator = document.getElementById('speed-bar-indicator');

        // Game state
        let useTilt = false, tiltReady = false, useDpad = false;
        let tiltSensitivity = 12, baseGamma = 0, baseBeta = 0, tiltGammaAvg = 0, tiltBetaAvg = 0, smoothingFactor = 0.25;
        let isPaused = false, gameStarted = false, dpadPos = { x: null, y: null }, dpadPlacementMode = false;
        let dpadDirection = null, dpadHoldStart = null, dpadHolding = false;
        const KEYBOARD_ACCEL = 7, DPAD_ACCEL = 3;
        let tileCount = 40, gridSize = 10, minSpeed = 25, maxSlowSpeed = 200;
        let snake, direction, nextDirection, food, score, holdingKey = false, heldDirection = null;
        let currentSpeed = 100, accelerationStep = KEYBOARD_ACCEL, decelerationStep = 6, animationFrameId = null, animState = "normal", animTick = 0, tiltMode = false, lastTiltDir = null;

        // Responsive canvas sizing
        function adjustGridForScreen() {
            let size = Math.min(window.innerWidth * 0.98, window.innerHeight * 0.74, 400);
            if (size < 240) tileCount = 10;
            else if (size < 340) tileCount = 16;
            else if (size < 400) tileCount = 22;
            else tileCount = 40;
            gridSize = Math.floor(size / tileCount);
            canvas.width = gridSize * tileCount;
            canvas.height = gridSize * tileCount;
        }
        function fitCanvas() {
            let size = Math.min(window.innerWidth * 0.98, window.innerHeight * 0.74, 400);
            canvas.style.width = size + "px";
            canvas.style.height = size + "px";
            adjustGridForScreen();
        }
        window.addEventListener("resize", fitCanvas);
        fitCanvas();

        function getNormalSpeed(score) {
            return Math.max(100 - Math.floor(score / 5) * 5, 45);
        }
        function isOppositeDirection(dir1, dir2) {
            return (
                (dir1 === 'left' && dir2 === 'right') ||
                (dir1 === 'right' && dir2 === 'left') ||
                (dir1 === 'up' && dir2 === 'down') ||
                (dir1 === 'down' && dir2 === 'up')
            );
        }
        function resetGameVars() {
            snake = [{ x: 10, y: 10 }];
            direction = 'right';
            nextDirection = 'right';
            food = getNewFoodPosition();
            score = 0;
            holdingKey = false;
            heldDirection = null;
            currentSpeed = getNormalSpeed(0);
            animState = "normal";
            animTick = 0;
            lastTiltDir = null;
        }

        // Control mode logic
        dpadModeBtn.onclick = function () {
            controlModal.style.display = "none";
            useDpad = true; useTilt = false;
            tiltSensitivityContainer.style.display = "none";
            setupDpad();
        };
        tiltModeBtn.onclick = function () {
            tiltSteps.style.display = "block";
            tiltPermBtn.disabled = false;
        };
        tiltPermBtn.onclick = function () {
            if (typeof DeviceOrientationEvent !== "undefined" && typeof DeviceOrientationEvent.requestPermission === "function") {
                DeviceOrientationEvent.requestPermission().then(response => {
                    if (response === "granted") {
                        tiltPermBtn.disabled = true;
                        tiltPermBtn.textContent = "Permission Granted!";
                        tiltCalibrateStep.style.display = "block";
                    } else alert("Permission denied.");
                });
            } else {
                tiltCalibrateStep.style.display = "block";
                tiltPermBtn.disabled = true;
                tiltPermBtn.textContent = "Permission Granted!";
            }
        };
        calibrateBtn.onclick = function () {
            window.addEventListener("deviceorientation", function once(e) {
                baseGamma = e.gamma || 0;
                baseBeta = e.beta || 0;
                tiltGammaAvg = baseGamma;
                tiltBetaAvg = baseBeta;
                tiltReady = true;
                controlModal.style.display = "none";
                startGameWithTilt();
                window.removeEventListener("deviceorientation", once);
            });
        };
        tiltSensitivityBar.oninput = function () {
            tiltSensitivity = Number(tiltSensitivityBar.value);
            tiltSensitivityValue.textContent = tiltSensitivity;
        };

        // --- Start functions ---
        function startGameWithTilt() {
            tiltMode = true; useTilt = true; useDpad = false;
            resetGameVars();
            tiltSensitivityContainer.style.display = "flex";
            pauseBtn.hidden = false;
            resetDpadBtn.hidden = true;
            dpadContainer.style.display = "none";
            window.addEventListener('deviceorientation', deviceTiltHandler);
            isPaused = false; hidePausedOverlay();
            gameStarted = true;
            accelerationStep = KEYBOARD_ACCEL;
            draw();
        }
        function startGameWithDpad() {
            tiltMode = false; useTilt = false; useDpad = true;
            resetGameVars();
            tiltSensitivityContainer.style.display = "none";
            pauseBtn.hidden = false;
            resetDpadBtn.hidden = false;
            isPaused = false; hidePausedOverlay();
            gameStarted = true;
            accelerationStep = DPAD_ACCEL;
            draw();
        }
        function startGameWithKeyboard() {
            resetGameVars();
            tiltSensitivityContainer.style.display = "none";
            pauseBtn.hidden = true;
            resetDpadBtn.hidden = true;
            dpadContainer.style.display = "none";
            isPaused = false; hidePausedOverlay();
            gameStarted = true;
            accelerationStep = KEYBOARD_ACCEL;
            draw();
        }

        // --- D-Pad logic ---
        function setupDpad() {
            pauseBtn.hidden = false;
            resetDpadBtn.hidden = false;
            if (dpadPos.x === null || dpadPos.y === null) showDpadPlacement();
            else {
                dpadContainer.style.display = "block";
                positionDpad(dpadPos.x, dpadPos.y);
                startGameWithDpad();
            }
        }
        function showDpadPlacement() {
            dpadPlacementMode = true;
            dpadPlacementOverlay.style.display = "flex";
            pauseBtn.hidden = true;
            resetDpadBtn.hidden = true;
            dpadContainer.style.display = "none";
            isPaused = true;
        }
        function hideDpadPlacement() {
            dpadPlacementMode = false;
            dpadPlacementOverlay.style.display = "none";
            pauseBtn.hidden = false;
            resetDpadBtn.hidden = false;
            dpadContainer.style.display = "block";
            isPaused = false;
            startGameWithDpad();
        }
        dpadPlacementOverlay.addEventListener('click', function (e) {
            let x = e.touches ? e.touches[0].clientX : e.clientX;
            let y = e.touches ? e.touches[0].clientY : e.clientY;
            let dpw = dpadContainer.offsetWidth || 92, dph = dpadContainer.offsetHeight || 92;
            x = Math.max(0, Math.min(window.innerWidth - dpw, x - dpw / 2));
            y = Math.max(0, Math.min(window.innerHeight - dph, y - dph / 2));
            dpadPos = { x, y };
            positionDpad(x, y);
            hideDpadPlacement();
        });
        function positionDpad(x, y) {
            dpadContainer.style.left = x + "px";
            dpadContainer.style.top = y + "px";
        }
        resetDpadBtn.onclick = showDpadPlacement;
        // --- D-Pad Button Handlers ---
        ["up", "down", "left", "right"].forEach(dir => {
            let btn = document.getElementById('dpad-' + dir);
            btn.addEventListener('touchstart', e => { e.preventDefault(); dpadPress(dir); }, { passive: false });
            btn.addEventListener('mousedown', e => { e.preventDefault(); dpadPress(dir); });
            btn.addEventListener('touchend', e => { e.preventDefault(); dpadRelease(dir); }, { passive: false });
            btn.addEventListener('mouseup', e => { e.preventDefault(); dpadRelease(dir); });
            btn.addEventListener('mouseleave', e => { dpadRelease(dir); });
        });
        function dpadPress(direction) {
            if (dpadPlacementMode) return;
            if (direction !== nextDirection && !isOppositeDirection(direction, nextDirection)) {
                nextDirection = direction;
            }
            dpadDirection = direction;
            dpadHoldStart = Date.now();
            dpadHolding = true;
            holdingKey = true;
            heldDirection = direction;
        }
        function dpadRelease(direction) {
            dpadHolding = false;
            holdingKey = false;
            heldDirection = null;
        }

        // --- Tap Key Controls for Desktop ---
        function tapKeydownHandler(e) {
            let pressed = false;
            switch (e.key) {
                case 'ArrowUp': case 'w': case 'W':
                    if (direction !== 'down') { nextDirection = 'up'; pressed = true; }
                    break;
                case 'ArrowDown': case 's': case 'S':
                    if (direction !== 'up') { nextDirection = 'down'; pressed = true; }
                    break;
                case 'ArrowLeft': case 'a': case 'A':
                    if (direction !== 'right') { nextDirection = 'left'; pressed = true; }
                    break;
                case 'ArrowRight': case 'd': case 'D':
                    if (direction !== 'left') { nextDirection = 'right'; pressed = true; }
                    break;
                case ' ':
                    togglePause();
                    break;
            }
            if (pressed) {
                holdingKey = true;
                heldDirection = nextDirection;
            } else if (
                (e.key === 'ArrowUp' && direction === 'down') ||
                (e.key === 'w' && direction === 'down') ||
                (e.key === 'ArrowDown' && direction === 'up') ||
                (e.key === 's' && direction === 'up') ||
                (e.key === 'ArrowLeft' && direction === 'right') ||
                (e.key === 'a' && direction === 'right') ||
                (e.key === 'ArrowRight' && direction === 'left') ||
                (e.key === 'd' && direction === 'left')
            ) {
                holdingKey = true;
                heldDirection = {
                    'ArrowUp': 'up', 'w': 'up', 'W': 'up',
                    'ArrowDown': 'down', 's': 'down', 'S': 'down',
                    'ArrowLeft': 'left', 'a': 'left', 'A': 'left',
                    'ArrowRight': 'right', 'd': 'right', 'D': 'right'
                }[e.key];
            }
        }
        function tapKeyupHandler(e) {
            if (
                (e.key === 'ArrowUp' && heldDirection === 'up') ||
                ((e.key === 'w' || e.key === 'W') && heldDirection === 'up') ||
                (e.key === 'ArrowDown' && heldDirection === 'down') ||
                ((e.key === 's' || e.key === 'S') && heldDirection === 'down') ||
                (e.key === 'ArrowLeft' && heldDirection === 'left') ||
                ((e.key === 'a' || e.key === 'A') && heldDirection === 'left') ||
                (e.key === 'ArrowRight' && heldDirection === 'right') ||
                ((e.key === 'd' || e.key === 'D') && heldDirection === 'right')
            ) {
                holdingKey = false;
                heldDirection = null;
            }
        }

        // --- Tilt Handler (with smoothing and sensitivity) ---
        function deviceTiltHandler(e) {
            if (!tiltMode || !tiltReady) return;
            tiltGammaAvg = tiltGammaAvg * (1 - smoothingFactor) + (e.gamma || 0) * smoothingFactor;
            tiltBetaAvg = tiltBetaAvg * (1 - smoothingFactor) + (e.beta || 0) * smoothingFactor;
            let dx = tiltGammaAvg - baseGamma;
            let dy = tiltBetaAvg - baseBeta;
            let newDir = null;
            if (dx > tiltSensitivity && direction !== 'left' && lastTiltDir !== 'right') {
                newDir = 'right';
            } else if (dx < -tiltSensitivity && direction !== 'right' && lastTiltDir !== 'left') {
                newDir = 'left';
            } else if (dy > tiltSensitivity && direction !== 'up' && lastTiltDir !== 'down') {
                newDir = 'down';
            } else if (dy < -tiltSensitivity && direction !== 'down' && lastTiltDir !== 'up') {
                newDir = 'up';
            }
            if (newDir) {
                nextDirection = newDir;
                holdingKey = true;
                heldDirection = newDir;
                lastTiltDir = newDir;
            } else {
                if (
                    (direction === 'left' && dx > tiltSensitivity / 2) ||
                    (direction === 'right' && dx < -tiltSensitivity / 2) ||
                    (direction === 'up' && dy > tiltSensitivity / 2) ||
                    (direction === 'down' && dy < -tiltSensitivity / 2)
                ) {
                    holdingKey = true;
                    heldDirection = (direction === 'left' || direction === 'right') ? (dx > 0 ? 'right' : 'left') : (dy > 0 ? 'down' : 'up');
                } else {
                    holdingKey = false;
                    heldDirection = null;
                    lastTiltDir = null;
                }
            }
        }

        // --- PAUSE FEATURE ---
        function togglePause() {
            if (!gameStarted) return;
            isPaused = !isPaused;
            if (isPaused) showPausedOverlay();
            else { hidePausedOverlay(); draw(); }
        }
        function resumeGame() {
            if (isPaused) {
                isPaused = false;
                hidePausedOverlay();
                draw();
            }
        }
        function showPausedOverlay() { pausedOverlay.style.display = "flex"; }
        function hidePausedOverlay() { pausedOverlay.style.display = "none"; }
        pauseBtn.onclick = togglePause;
        window.addEventListener('keydown', function (e) {
            if (e.key === 'Escape' || e.key === 'p' || e.key === 'P') togglePause();
        });

        // --- Main Game Loop ---
        function draw() {
            if (isPaused) return;
            let targetNormalSpeed = getNormalSpeed(score);
            if (holdingKey && heldDirection === direction && currentSpeed < targetNormalSpeed - 3) animState = "accelerating";
            else if (holdingKey && isOppositeDirection(heldDirection, direction) && currentSpeed > targetNormalSpeed + 3) animState = "braking";
            else animState = "normal";
            if (holdingKey && heldDirection === direction) {
                currentSpeed -= accelerationStep;
                if (currentSpeed < minSpeed) currentSpeed = minSpeed;
            } else if (holdingKey && isOppositeDirection(heldDirection, direction)) {
                currentSpeed += decelerationStep * 2;
                if (currentSpeed > maxSlowSpeed) currentSpeed = maxSlowSpeed;
            } else {
                if (currentSpeed > targetNormalSpeed) {
                    currentSpeed -= decelerationStep;
                    if (currentSpeed < targetNormalSpeed) currentSpeed = targetNormalSpeed;
                } else if (currentSpeed < targetNormalSpeed) {
                    currentSpeed += decelerationStep;
                    if (currentSpeed > targetNormalSpeed) currentSpeed = targetNormalSpeed;
                }
            }
            direction = nextDirection;
            const head = { ...snake[0] };
            switch (direction) {
                case 'up': head.y--; break;
                case 'down': head.y++; break;
                case 'left': head.x--; break;
                case 'right': head.x++; break;
            }
            snake.unshift(head);
            if (head.x < 0 || head.x >= tileCount || head.y < 0 || head.y >= tileCount) { gameOver(); return; }
            if (snake.slice(1).some(segment => segment.x === head.x && segment.y === head.y)) { gameOver(); return; }
            if (head.x === food.x && head.y === food.y) { score++; food = getNewFoodPosition(); }
            else snake.pop();
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            ctx.save();
            ctx.shadowColor = '#ef4444aa'; ctx.shadowBlur = 7;
            ctx.beginPath();
            ctx.arc(food.x * gridSize + gridSize / 2, food.y * gridSize + gridSize / 2, gridSize / 2 - 1, 0, Math.PI * 2);
            ctx.closePath();
            ctx.fillStyle = '#fb7185';
            ctx.fill();
            ctx.restore();
            animTick++;
            if (animTick > 10000) animTick = 0;
            for (let i = 0; i < snake.length; i++) {
                ctx.save();
                if (i === 0) {
                    let x = snake[i].x * gridSize + gridSize / 2;
                    let y = snake[i].y * gridSize + gridSize / 2;
                    if (animState === "accelerating") { drawSpeedLines(ctx, x, y, direction, animTick); drawPointyHead(ctx, x, y, direction); }
                    else if (animState === "braking") { drawBrakeWave(ctx, x, y, animTick); drawPuffyHead(ctx, x, y); }
                    else { ctx.shadowColor = "#22d3ee"; ctx.shadowBlur = 6; ctx.fillStyle = "#0ea5e9"; roundedRect(ctx, x - gridSize / 2, y - gridSize / 2, gridSize, gridSize, 3.5); ctx.fill(); }
                } else {
                    ctx.shadowColor = "#a5f3fc66";
                    ctx.shadowBlur = 6;
                    ctx.fillStyle = "#38bdf8";
                    const x = snake[i].x * gridSize;
                    const y = snake[i].y * gridSize;
                    roundedRect(ctx, x, y, gridSize, gridSize, 3);
                    ctx.fill();
                }
                ctx.restore();
            }
            scoreBar.innerHTML = `Score: <span style="color:#06b6d4">${score}</span>`;
            updateSpeedBar(animState, currentSpeed, getNormalSpeed(score), minSpeed, maxSlowSpeed);
            animationFrameId = setTimeout(() => requestAnimationFrame(draw), currentSpeed);
        }
        function drawPointyHead(ctx, x, y, direction) {
            ctx.save(); ctx.shadowColor = "#06b6d4"; ctx.shadowBlur = 22;
            ctx.fillStyle = "#0ea5e9"; ctx.strokeStyle = "#22d3ee"; ctx.lineWidth = 2;
            let len = gridSize * 1.8, w = gridSize * 1.05, base = gridSize * 0.7;
            ctx.beginPath();
            if (direction === 'right') { ctx.moveTo(x + len / 2, y); ctx.lineTo(x - base / 2, y - w / 2); ctx.lineTo(x - base / 2, y + w / 2); }
            else if (direction === 'left') { ctx.moveTo(x - len / 2, y); ctx.lineTo(x + base / 2, y - w / 2); ctx.lineTo(x + base / 2, y + w / 2); }
            else if (direction === 'up') { ctx.moveTo(x, y - len / 2); ctx.lineTo(x - w / 2, y + base / 2); ctx.lineTo(x + w / 2, y + base / 2); }
            else if (direction === 'down') { ctx.moveTo(x, y + len / 2); ctx.lineTo(x - w / 2, y - base / 2); ctx.lineTo(x + w / 2, y - base / 2); }
            ctx.closePath(); ctx.fill(); ctx.stroke(); ctx.restore();
        }
        function drawSpeedLines(ctx, x, y, direction, tick) {
            ctx.save(); ctx.globalAlpha = 0.42; ctx.strokeStyle = "#0ea5e9"; ctx.lineWidth = 2.7;
            let spacing = 6, lines = 4, offset = Math.sin(tick * 0.25) * 2;
            for (let i = 0; i < lines; i++) {
                let factor = i - (lines - 1) / 2;
                if (direction === 'right') { ctx.beginPath(); ctx.moveTo(x - 14, y + factor * spacing + offset); ctx.lineTo(x - 25, y + factor * spacing + offset); ctx.stroke(); }
                else if (direction === 'left') { ctx.beginPath(); ctx.moveTo(x + 14, y + factor * spacing + offset); ctx.lineTo(x + 25, y + factor * spacing + offset); ctx.stroke(); }
                else if (direction === 'up') { ctx.beginPath(); ctx.moveTo(x + factor * spacing + offset, y + 14); ctx.lineTo(x + factor * spacing + offset, y + 25); ctx.stroke(); }
                else if (direction === 'down') { ctx.beginPath(); ctx.moveTo(x + factor * spacing + offset, y - 14); ctx.lineTo(x + factor * spacing + offset, y - 25); ctx.stroke(); }
            }
            ctx.globalAlpha = 1; ctx.restore();
        }
        function drawPuffyHead(ctx, x, y) {
            ctx.save(); ctx.shadowColor = "#fb7185"; ctx.shadowBlur = 20; ctx.fillStyle = "#f59e42";
            ctx.beginPath(); ctx.arc(x, y, gridSize * 0.87 + Math.sin(animTick * 0.20) * 2, 0, Math.PI * 2); ctx.closePath(); ctx.fill(); ctx.restore();
        }
        function drawBrakeWave(ctx, x, y, tick) {
            ctx.save(); let baseR = gridSize * 1.1;
            for (let i = 0; i < 3; i++) {
                ctx.beginPath(); ctx.globalAlpha = 0.21 - i * 0.05; ctx.strokeStyle = "#fb7185"; ctx.lineWidth = 3 - i;
                let waveRadius = baseR + Math.abs(Math.sin(tick * 0.23 + i)) * (10 + i * 5);
                ctx.arc(x, y, waveRadius, 0, Math.PI * 2); ctx.stroke();
            }
            ctx.globalAlpha = 1; ctx.restore();
        }
        function updateSpeedBar(animState, currentSpeed, normalSpeed, minSpeed, maxSlowSpeed) {
            let val = 0;
            if (currentSpeed > normalSpeed) val = -Math.min((currentSpeed - normalSpeed) / (maxSlowSpeed - normalSpeed), 1);
            else if (currentSpeed < normalSpeed) val = Math.min((normalSpeed - currentSpeed) / (normalSpeed - minSpeed), 1);
            let bar = speedBar, barIndicator = speedBarIndicator;
            let px = ((val + 1) / 2) * bar.offsetWidth, width = bar.offsetWidth * 0.09 + Math.abs(val) * bar.offsetWidth * 0.4;
            px = Math.max(2, Math.min(bar.offsetWidth - width - 2, px - width / 2));
            let bg = "#93c5fd";
            if (animState === "accelerating") bg = "linear-gradient(90deg,#38bdf8 40%,#06b6d4 100%)";
            if (animState === "braking") bg = "linear-gradient(90deg,#fb7185 10%,#f43f5e 80%)";
            barIndicator.style.left = px + "px";
            barIndicator.style.width = width + "px";
            barIndicator.style.height = "100%";
            barIndicator.style.background = bg;
            barIndicator.style.boxShadow = (animState !== "normal") ? `0 0 16px 3px ${animState === "accelerating" ? "#06b6d4" : "#f43f5e"}99` : "none";
        }
        function getNewFoodPosition() {
            let pos;
            while (true) {
                pos = { x: Math.floor(Math.random() * tileCount), y: Math.floor(Math.random() * tileCount) };
                if (!snake.some(segment => segment.x === pos.x && segment.y === pos.y)) return pos;
            }
        }
        function gameOver() {
            clearTimeout(animationFrameId);
            setTimeout(() => {
                alert(`Game Over! Your score: ${score}`);
                resetGameVars();
                draw();
            }, 200);
        }
        function roundedRect(ctx, x, y, w, h, r) {
            ctx.beginPath();
            ctx.moveTo(x + r, y);
            ctx.lineTo(x + w - r, y);
            ctx.quadraticCurveTo(x + w, y, x + w, y + r);
            ctx.lineTo(x + w, y + h - r);
            ctx.quadraticCurveTo(x + w, y + h, x + w - r, y + h);
            ctx.lineTo(x + r, y + h);
            ctx.quadraticCurveTo(x, y + h, x, y + h - r);
            ctx.lineTo(x, y + r);
            ctx.quadraticCurveTo(x, y, x + r, y);
            ctx.closePath();
        }

        // Service Worker registration for PWA (optional, harmless if missing)
        if ('serviceWorker' in navigator) {
            window.addEventListener('load', function () {
                navigator.serviceWorker.register('./service-worker.js');
            });
        }

        // --- On Load ---
        window.onload = function () {
            fitCanvas();
            if (isTouchDevice()) {
                controlModal.style.display = "flex";
                pauseBtn.hidden = true;
                resetDpadBtn.hidden = true;
            } else {
                // Desktop: attach keyboard handlers, hide touch UI
                pauseBtn.hidden = true;
                resetDpadBtn.hidden = true;
                dpadContainer.style.display = "none";
                document.addEventListener('keydown', tapKeydownHandler);
                document.addEventListener('keyup', tapKeyupHandler);
                startGameWithKeyboard();
            }
        };

    </script>
</body>

</html>