<!DOCTYPE html>
<html lang="en">

<head>
    <link rel="manifest" href="manifest.json">
    <meta name="theme-color" content="#38bdf8">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="#38bdf8">
    <link rel="apple-touch-icon" href="icon-192.png">
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Modern Snake Game (Edge Swipe)</title>
    <style>
        body {
            background: linear-gradient(135deg, #e9e9f2 0%, #f6faff 100%);
            min-height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
            margin: 0;
        }

        .game-container {
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        #score-bar {
            font-family: 'Segoe UI', Arial, sans-serif;
            font-size: 1.3rem;
            font-weight: 600;
            color: #334155;
            margin-bottom: 10px;
            letter-spacing: 0.5px;
            background: #fff;
            padding: 8px 30px;
            border-radius: 22px;
            box-shadow: 0 2px 8px #93c5fd33;
            user-select: none;
        }

        #speed-bar-container {
            width: 410px;
            margin-bottom: 16px;
            margin-top: 2px;
            display: flex;
            flex-direction: column;
            align-items: center;
            font-family: 'Segoe UI', Arial, sans-serif;
        }

        #speed-bar-labels {
            width: 100%;
            display: flex;
            justify-content: space-between;
            font-size: 11px;
            color: #64748b;
            padding: 0 6px;
            box-sizing: border-box;
        }

        #speed-bar {
            width: 100%;
            height: 16px;
            background: #f3f4f6;
            border-radius: 8px;
            border: 2px solid #cbd5e1;
            box-shadow: 0 2px 8px #bae6fd66;
            position: relative;
            overflow: hidden;
            margin-bottom: 2px;
            margin-top: 3px;
        }

        #speed-bar-indicator {
            position: absolute;
            top: 0;
            bottom: 0;
            height: 100%;
            border-radius: 8px;
            transition: left 0.08s cubic-bezier(.4, 2, .7, 1), width 0.1s cubic-bezier(.4, 2, .7, 1), background 0.2s;
        }

        #control-modal {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.75);
            z-index: 20;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
        }

        #control-modal>div {
            background: #fff;
            padding: 30px 25px 20px 25px;
            border-radius: 20px;
            text-align: center;
            min-width: 250px;
            max-width: 94vw;
        }

        #control-modal button {
            font-size: 1em;
            padding: 10px 30px;
            margin: 8px 0;
            border-radius: 10px;
            border: none;
            background: #38bdf8;
            color: #fff;
            cursor: pointer;
            transition: background 0.16s;
        }

        #control-modal button:active {
            background: #0ea5e9;
        }

        #control-modal button:disabled {
            background: #ddd !important;
            color: #aaa !important;
            cursor: not-allowed;
        }

        #tilt-sensitivity-container {
            margin: 10px 0 0 0;
            padding: 10px;
            border-radius: 8px;
            background: #f6faff;
            box-shadow: 0 2px 10px #bae6fd33;
            display: none;
            align-items: center;
            justify-content: center;
            gap: 12px;
        }

        #tilt-sensitivity-bar {
            width: 150px;
        }

        canvas {
            background: #f8fafc;
            border: 4px solid #38bdf8;
            border-radius: 22px;
            box-shadow: 0 8px 32px #38bdf866, 0 0 0 2px #bae6fd88;
            display: block;
            margin-top: 16px;
            touch-action: none;
            -webkit-user-select: none;
            user-select: none;
        }

        /* EDGE SWIPE CONTROL AREA */
        @media (max-width: 600px) {
            #swipe-edge-area {
                position: fixed;
                left: 0;
                top: 0;
                width: 100vw;
                height: 100vh;
                z-index: 130;
                background: rgba(0, 0, 0, 0);
                touch-action: none;
                user-select: none;
            }

            .game-container {
                gap: 10vw;
            }

            #score-bar {
                margin-bottom: 3vw;
            }

            #speed-bar-container {
                margin-bottom: 2vw;
            }

            canvas#gameCanvas {
                margin-top: 3vw;
            }
        }
    </style>
</head>

<body>
    <input type="checkbox" id="haptic-switch" switch style="display:none">
    <div class="game-container">
        <div id="score-bar">Score: 0</div>
        <div id="speed-bar-container">
            <div id="speed-bar-labels">
                <span style="color:#f43f5e">Braking</span>
                <span style="color:#64748b;">Normal</span>
                <span style="color:#06b6d4">Accelerating</span>
            </div>
            <div id="speed-bar">
                <div id="speed-bar-indicator"></div>
            </div>
        </div>
        <div id="tilt-sensitivity-container">
            <span>Motion Sensitivity</span>
            <input id="tilt-sensitivity-bar" type="range" min="5" max="35" value="12">
            <span id="tilt-sensitivity-value">12</span>
        </div>
        <canvas id="gameCanvas" width="400" height="400"
            style="max-width:96vw;max-height:96vw;min-width:220px;min-height:220px;"></canvas>
    </div>
    <!-- EDGE SWIPE AREA -->
    <div id="swipe-edge-area" style="display:none"></div>
    <div id="swipe-hint-overlay"
        style="display:none;position:fixed;left:0;top:0;width:100vw;height:100vh;background:rgba(56,189,248,0.18);z-index:200;align-items:center;justify-content:center;pointer-events:none;">
        <div style="font-size:2.2em;color:#0ea5e9;text-shadow:0 2px 16px #fff,0 0 8px #bae6fd;">
            <div style="font-size:1.1em;">Swipe anywhere</div>
            <div style="font-size:0.7em;opacity:0.83;margin-bottom:12px;">to turn the snake</div>
            <div>
                <span style="font-size:1.8em;vertical-align:middle;">⬅️</span>
                <span style="font-size:1.5em;vertical-align:middle;">⬆️</span>
                <span style="font-size:1.8em;vertical-align:middle;">➡️</span>
                <span style="font-size:1.5em;vertical-align:middle;">⬇️</span>
            </div>
        </div>
    </div>
    <!-- Control Modal -->
    <div id="control-modal">
        <div>
            <h2 style="margin:0 0 18px;font-size:1.5em;">Choose Control Mode</h2>
            <button id="tap-mode-btn">Touch/Arrow Keys</button><br>
            <button id="tilt-mode-btn">Tilt (iPhone/Android)</button>
            <div id="tilt-steps" style="display:none;margin-top:18px;">
                <div id="tilt-permission-step">
                    <button id="tilt-perm-btn">Enable Tilt</button>
                </div>
                <div id="tilt-calibrate-step" style="display:none;">
                    <div style="margin-bottom:7px;">
                        Hold your phone in comfortable play position.<br>
                        Then tap Calibrate.
                    </div>
                    <button id="calibrate-btn">Calibrate</button>
                </div>
            </div>
        </div>
    </div>
    <script>
        // --- Haptic Feedback Utilities ---
        function isIOS() {
            return /iP(hone|od|ad)/.test(navigator.userAgent);
        }
        function isiOS18OrLater() {
            return isIOS() && /OS 1[8-9](_\d+)?\s/.test(navigator.userAgent);
        }
        function triggerHapticFallback() {
            const cb = document.getElementById('haptic-switch');
            cb.checked = !cb.checked;
        }
        function hapticFeedback(duration) {
            if ('vibrate' in navigator) {
                navigator.vibrate(duration || 30);
            } else if (isiOS18OrLater()) {
                triggerHapticFallback();
            }
        }
        // --- Device and UI Elements ---
        function tiltIsSupported() {
            return typeof DeviceOrientationEvent !== "undefined" &&
                typeof DeviceOrientationEvent.requestPermission === "function";
        }
        let controlModal = document.getElementById("control-modal");
        let tapModeBtn = document.getElementById("tap-mode-btn");
        let tiltModeBtn = document.getElementById("tilt-mode-btn");
        let tiltSteps = document.getElementById("tilt-steps");
        let tiltPermBtn = document.getElementById("tilt-perm-btn");
        let tiltCalibrateStep = document.getElementById("tilt-calibrate-step");
        let calibrateBtn = document.getElementById("calibrate-btn");
        let tiltSensitivityContainer = document.getElementById("tilt-sensitivity-container");
        let tiltSensitivityBar = document.getElementById("tilt-sensitivity-bar");
        let tiltSensitivityValue = document.getElementById("tilt-sensitivity-value");
        // --- Game State ---
        let useTilt = false, tiltReady = false;
        let tiltSensitivity = 12;
        let baseGamma = 0, baseBeta = 0;
        let tiltGammaAvg = 0, tiltBetaAvg = 0;
        let smoothingFactor = 0.25;
        let gameStarted = false;

        // --- Swipe Hint Overlay for Mobile ---
        const swipeHintOverlay = document.getElementById('swipe-hint-overlay');
        function showSwipeHint() {
            if (!isTouchDevice()) return;
            swipeHintOverlay.style.display = 'flex';
            setTimeout(() => {
                swipeHintOverlay.style.transition = "opacity 0.8s";
                swipeHintOverlay.style.opacity = "0";
                setTimeout(() => {
                    swipeHintOverlay.style.display = 'none';
                    swipeHintOverlay.style.opacity = "";
                    swipeHintOverlay.style.transition = "";
                }, 800);
            }, 1750);
        }

        // --- Control Modal Selection Logic ---
        tapModeBtn.onclick = function () {
            controlModal.style.display = "none";
            startGameWithTap();
        };
        tiltModeBtn.onclick = function () {
            tiltSteps.style.display = "block";
            tiltPermBtn.disabled = false;
        };
        tiltPermBtn.onclick = function () {
            if (typeof DeviceOrientationEvent !== "undefined" && typeof DeviceOrientationEvent.requestPermission === "function") {
                DeviceOrientationEvent.requestPermission().then(response => {
                    if (response === "granted") {
                        tiltPermBtn.disabled = true;
                        tiltPermBtn.textContent = "Permission Granted!";
                        tiltCalibrateStep.style.display = "block";
                    } else {
                        alert("Permission denied.");
                    }
                });
            } else {
                // Non-iOS: proceed immediately
                tiltCalibrateStep.style.display = "block";
                tiltPermBtn.disabled = true;
                tiltPermBtn.textContent = "Permission Granted!";
            }
        };
        calibrateBtn.onclick = function () {
            // Read current tilt as "base"
            window.addEventListener("deviceorientation", function once(e) {
                baseGamma = e.gamma || 0;
                baseBeta = e.beta || 0;
                tiltGammaAvg = baseGamma;
                tiltBetaAvg = baseBeta;
                tiltReady = true;
                controlModal.style.display = "none";
                startGameWithTilt();
                window.removeEventListener("deviceorientation", once);
            });
        };
        tiltSensitivityBar.oninput = function () {
            tiltSensitivity = Number(tiltSensitivityBar.value);
            tiltSensitivityValue.textContent = tiltSensitivity;
        };
        // --- Game Logic and Variables ---
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const scoreBar = document.getElementById('score-bar');
        const speedBar = document.getElementById('speed-bar');
        const speedBarIndicator = document.getElementById('speed-bar-indicator');
        let tileCount = 40;
        let gridSize = 10;

        // Dynamically set grid for mobile screens
        function adjustGridForScreen() {
            let size = Math.min(window.innerWidth * 0.96, window.innerHeight * 0.7, 400);
            if (size < 340) {
                tileCount = 16;
            } else if (size < 400) {
                tileCount = 22;
            } else {
                tileCount = 40;
            }
            gridSize = Math.floor(size / tileCount);
            canvas.width = gridSize * tileCount;
            canvas.height = gridSize * tileCount;
        }
        let snake, direction, nextDirection, food, score;
        let holdingKey = false;
        let heldDirection = null;
        let minSpeed = 25;
        let maxSlowSpeed = 200;
        let currentSpeed = 100;
        let accelerationStep = 7;
        let decelerationStep = 6;
        let animationFrameId = null;
        let animState = "normal";
        let animTick = 0;
        let tiltMode = false;
        let lastTiltDir = null;
        function isTouchDevice() {
            return 'ontouchstart' in window || navigator.maxTouchPoints > 0;
        }
        function getNormalSpeed(score) {
            return Math.max(100 - Math.floor(score / 5) * 5, 45);
        }
        function isOppositeDirection(dir1, dir2) {
            return (
                (dir1 === 'left' && dir2 === 'right') ||
                (dir1 === 'right' && dir2 === 'left') ||
                (dir1 === 'up' && dir2 === 'down') ||
                (dir1 === 'down' && dir2 === 'up')
            );
        }
        function resetGameVars() {
            snake = [{ x: 10, y: 10 }];
            direction = 'right';
            nextDirection = 'right';
            food = getNewFoodPosition();
            score = 0;
            holdingKey = false;
            heldDirection = null;
            currentSpeed = getNormalSpeed(0);
            animState = "normal";
            animTick = 0;
            lastTiltDir = null;
        }
        function startGameWithTap() {
            tiltMode = false;
            resetGameVars();
            tiltSensitivityContainer.style.display = "none";
            if (!gameStarted) {
                document.addEventListener('keydown', tapKeydownHandler);
                document.addEventListener('keyup', tapKeyupHandler);
            }
            if (isTouchDevice()) {
                enableSwipeControls();
                showSwipeHint();
            } else {
                disableSwipeControls();
            }
            gameStarted = true;
            draw();
        }
        function startGameWithTilt() {
            tiltMode = true;
            resetGameVars();
            tiltSensitivityContainer.style.display = "flex";
            window.addEventListener('deviceorientation', deviceTiltHandler);
            gameStarted = true;
            draw();
        }
        // --- Tap Key Controls for Desktop ---
        function tapKeydownHandler(e) {
            let pressed = false;
            switch (e.key) {
                case 'ArrowUp': case 'w': case 'W':
                    if (direction !== 'down') {
                        nextDirection = 'up'; pressed = true;
                    }
                    break;
                case 'ArrowDown': case 's': case 'S':
                    if (direction !== 'up') {
                        nextDirection = 'down'; pressed = true;
                    }
                    break;
                case 'ArrowLeft': case 'a': case 'A':
                    if (direction !== 'right') {
                        nextDirection = 'left'; pressed = true;
                    }
                    break;
                case 'ArrowRight': case 'd': case 'D':
                    if (direction !== 'left') {
                        nextDirection = 'right'; pressed = true;
                    }
                    break;
            }
            if (pressed) {
                holdingKey = true;
                heldDirection = nextDirection;
            } else if (
                (e.key === 'ArrowUp' && direction === 'down') ||
                (e.key === 'w' && direction === 'down') ||
                (e.key === 'ArrowDown' && direction === 'up') ||
                (e.key === 's' && direction === 'up') ||
                (e.key === 'ArrowLeft' && direction === 'right') ||
                (e.key === 'a' && direction === 'right') ||
                (e.key === 'ArrowRight' && direction === 'left') ||
                (e.key === 'd' && direction === 'left')
            ) {
                holdingKey = true;
                heldDirection = {
                    'ArrowUp': 'up', 'w': 'up', 'W': 'up',
                    'ArrowDown': 'down', 's': 'down', 'S': 'down',
                    'ArrowLeft': 'left', 'a': 'left', 'A': 'left',
                    'ArrowRight': 'right', 'd': 'right', 'D': 'right'
                }[e.key];
            }
        }
        function tapKeyupHandler(e) {
            if (
                (e.key === 'ArrowUp' && heldDirection === 'up') ||
                ((e.key === 'w' || e.key === 'W') && heldDirection === 'up') ||
                (e.key === 'ArrowDown' && heldDirection === 'down') ||
                ((e.key === 's' || e.key === 'S') && heldDirection === 'down') ||
                (e.key === 'ArrowLeft' && heldDirection === 'left') ||
                ((e.key === 'a' || e.key === 'A') && heldDirection === 'left') ||
                (e.key === 'ArrowRight' && heldDirection === 'right') ||
                ((e.key === 'd' || e.key === 'D') && heldDirection === 'right')
            ) {
                holdingKey = false;
                heldDirection = null;
            }
        }
        // --- Tilt Handler (with smoothing and sensitivity) ---
        function deviceTiltHandler(e) {
            if (!tiltMode || !tiltReady) return;
            tiltGammaAvg = tiltGammaAvg * (1 - smoothingFactor) + (e.gamma || 0) * smoothingFactor;
            tiltBetaAvg = tiltBetaAvg * (1 - smoothingFactor) + (e.beta || 0) * smoothingFactor;
            let dx = tiltGammaAvg - baseGamma;
            let dy = tiltBetaAvg - baseBeta;
            let newDir = null;
            if (dx > tiltSensitivity && direction !== 'left' && lastTiltDir !== 'right') {
                newDir = 'right';
            } else if (dx < -tiltSensitivity && direction !== 'right' && lastTiltDir !== 'left') {
                newDir = 'left';
            } else if (dy > tiltSensitivity && direction !== 'up' && lastTiltDir !== 'down') {
                newDir = 'down';
            } else if (dy < -tiltSensitivity && direction !== 'down' && lastTiltDir !== 'up') {
                newDir = 'up';
            }
            if (newDir) {
                nextDirection = newDir;
                holdingKey = true;
                heldDirection = newDir;
                lastTiltDir = newDir;
            } else {
                if (
                    (direction === 'left' && dx > tiltSensitivity / 2) ||
                    (direction === 'right' && dx < -tiltSensitivity / 2) ||
                    (direction === 'up' && dy > tiltSensitivity / 2) ||
                    (direction === 'down' && dy < -tiltSensitivity / 2)
                ) {
                    holdingKey = true;
                    heldDirection = (direction === 'left' || direction === 'right') ? (dx > 0 ? 'right' : 'left') : (dy > 0 ? 'down' : 'up');
                } else {
                    holdingKey = false;
                    heldDirection = null;
                    lastTiltDir = null;
                }
            }
        }

        // --- EDGE SWIPE CONTROLS FOR MOBILE ---
        const swipeEdgeArea = document.getElementById('swipe-edge-area');
        let swipeStart = null;
        let swipeActive = false;
        let swipeAccel = false;
        let swipeDir = null;
        function enableSwipeControls() {
            if (!isTouchDevice()) return;
            swipeEdgeArea.style.display = 'block';
        }
        function disableSwipeControls() {
            swipeEdgeArea.style.display = 'none';
        }
        function swipeDirection(dx, dy) {
            if (Math.abs(dx) > Math.abs(dy)) {
                if (dx > 16) return 'right';
                if (dx < -16) return 'left';
            } else {
                if (dy > 16) return 'down';
                if (dy < -16) return 'up';
            }
            return null;
        }
        swipeEdgeArea.addEventListener('touchstart', function (e) {
            const touch = e.touches[0];
            swipeStart = { x: touch.clientX, y: touch.clientY, t: Date.now() };
            swipeActive = true;
            swipeAccel = false;
            swipeDir = null;
        }, { passive: false });
        swipeEdgeArea.addEventListener('touchmove', function (e) {
            if (!swipeActive) return;
            const touch = e.touches[0];
            let dx = touch.clientX - swipeStart.x;
            let dy = touch.clientY - swipeStart.y;
            let dir = swipeDirection(dx, dy);
            if (dir && dir !== direction && !isOppositeDirection(dir, direction)) {
                nextDirection = dir;
                swipeDir = dir;
                swipeAccel = true;
                holdingKey = true;
                heldDirection = dir;
            }
            // If finger moves far in current direction, keep accelerating
            if (dir === direction && (Math.abs(dx) > 32 || Math.abs(dy) > 32)) {
                swipeAccel = true;
                holdingKey = true;
                heldDirection = dir;
            }
        }, { passive: false });
        swipeEdgeArea.addEventListener('touchend', function (e) {
            swipeActive = false;
            swipeAccel = false;
            swipeDir = null;
            holdingKey = false;
            heldDirection = null;
        }, { passive: false });
        // Prevent accidental scrolling
        swipeEdgeArea.addEventListener('touchmove', function (e) { e.preventDefault(); }, { passive: false });

        // --- Main Game Loop ---
        function draw() {
            let targetNormalSpeed = getNormalSpeed(score);
            if (isTouchDevice() && swipeActive && swipeDir && !tiltMode) {
                if (swipeDir && heldDirection === direction) {
                    currentSpeed = Math.max(targetNormalSpeed * 0.7, 18);
                } else if (swipeDir && isOppositeDirection(swipeDir, direction)) {
                    currentSpeed = Math.min(targetNormalSpeed * 1.5, 220);
                }
            }
            if (holdingKey && heldDirection === direction && currentSpeed < targetNormalSpeed - 3) {
                animState = "accelerating";
            } else if (holdingKey && isOppositeDirection(heldDirection, direction) && currentSpeed > targetNormalSpeed + 3) {
                animState = "braking";
            } else {
                animState = "normal";
            }
            if (holdingKey && heldDirection === direction) {
                currentSpeed -= accelerationStep;
                if (currentSpeed < minSpeed) currentSpeed = minSpeed;
            } else if (holdingKey && isOppositeDirection(heldDirection, direction)) {
                currentSpeed += decelerationStep * 2;
                if (currentSpeed > maxSlowSpeed) currentSpeed = maxSlowSpeed;
            } else {
                if (currentSpeed > targetNormalSpeed) {
                    currentSpeed -= decelerationStep;
                    if (currentSpeed < targetNormalSpeed) currentSpeed = targetNormalSpeed;
                } else if (currentSpeed < targetNormalSpeed) {
                    currentSpeed += decelerationStep;
                    if (currentSpeed > targetNormalSpeed) currentSpeed = targetNormalSpeed;
                }
            }
            direction = nextDirection;
            const head = { ...snake[0] };
            switch (direction) {
                case 'up': head.y--; break;
                case 'down': head.y++; break;
                case 'left': head.x--; break;
                case 'right': head.x++; break;
            }
            snake.unshift(head);
            if (head.x < 0 || head.x >= tileCount || head.y < 0 || head.y >= tileCount) {
                gameOver(); return;
            }
            if (snake.slice(1).some(segment => segment.x === head.x && segment.y === head.y)) {
                gameOver(); return;
            }
            if (head.x === food.x && head.y === food.y) {
                score++;
                food = getNewFoodPosition();
            } else {
                snake.pop();
            }
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            ctx.save();
            ctx.shadowColor = '#ef4444aa';
            ctx.shadowBlur = 7;
            ctx.beginPath();
            ctx.arc(food.x * gridSize + gridSize / 2, food.y * gridSize + gridSize / 2, gridSize / 2 - 1, 0, Math.PI * 2);
            ctx.closePath();
            ctx.fillStyle = '#fb7185';
            ctx.fill();
            ctx.restore();
            animTick++;
            if (animTick > 10000) animTick = 0;
            for (let i = 0; i < snake.length; i++) {
                ctx.save();
                if (i === 0) {
                    let x = snake[i].x * gridSize + gridSize / 2;
                    let y = snake[i].y * gridSize + gridSize / 2;
                    if (animState === "accelerating") {
                        drawSpeedLines(ctx, x, y, direction, animTick);
                        drawPointyHead(ctx, x, y, direction);
                    } else if (animState === "braking") {
                        drawBrakeWave(ctx, x, y, animTick);
                        drawPuffyHead(ctx, x, y);
                    } else {
                        ctx.shadowColor = "#22d3ee";
                        ctx.shadowBlur = 6;
                        ctx.fillStyle = "#0ea5e9";
                        roundedRect(ctx, x - gridSize / 2, y - gridSize / 2, gridSize, gridSize, 3.5);
                        ctx.fill();
                    }
                } else {
                    ctx.shadowColor = "#a5f3fc66";
                    ctx.shadowBlur = 6;
                    ctx.fillStyle = "#38bdf8";
                    const x = snake[i].x * gridSize;
                    const y = snake[i].y * gridSize;
                    roundedRect(ctx, x, y, gridSize, gridSize, 3);
                    ctx.fill();
                }
                ctx.restore();
            }
            scoreBar.innerHTML = `Score: <span style="color:#06b6d4">${score}</span>`;
            updateSpeedBar(animState, currentSpeed, getNormalSpeed(score), minSpeed, maxSlowSpeed);
            animationFrameId = setTimeout(() => requestAnimationFrame(draw), currentSpeed);
        }
        function drawPointyHead(ctx, x, y, direction) {
            ctx.save();
            ctx.shadowColor = "#06b6d4";
            ctx.shadowBlur = 22;
            ctx.fillStyle = "#0ea5e9";
            ctx.strokeStyle = "#22d3ee";
            ctx.lineWidth = 2;
            let len = gridSize * 1.8, w = gridSize * 1.05;
            let base = gridSize * 0.7;
            ctx.beginPath();
            if (direction === 'right') {
                ctx.moveTo(x + len / 2, y);
                ctx.lineTo(x - base / 2, y - w / 2);
                ctx.lineTo(x - base / 2, y + w / 2);
            } else if (direction === 'left') {
                ctx.moveTo(x - len / 2, y);
                ctx.lineTo(x + base / 2, y - w / 2);
                ctx.lineTo(x + base / 2, y + w / 2);
            } else if (direction === 'up') {
                ctx.moveTo(x, y - len / 2);
                ctx.lineTo(x - w / 2, y + base / 2);
                ctx.lineTo(x + w / 2, y + base / 2);
            } else if (direction === 'down') {
                ctx.moveTo(x, y + len / 2);
                ctx.lineTo(x - w / 2, y - base / 2);
                ctx.lineTo(x + w / 2, y - base / 2);
            }
            ctx.closePath();
            ctx.fill();
            ctx.stroke();
            ctx.restore();
        }
        function drawSpeedLines(ctx, x, y, direction, tick) {
            ctx.save();
            ctx.globalAlpha = 0.42;
            ctx.strokeStyle = "#0ea5e9";
            ctx.lineWidth = 2.7;
            let spacing = 6, lines = 4;
            let offset = Math.sin(tick * 0.25) * 2;
            for (let i = 0; i < lines; i++) {
                let factor = i - (lines - 1) / 2;
                if (direction === 'right') {
                    ctx.beginPath();
                    ctx.moveTo(x - 14, y + factor * spacing + offset);
                    ctx.lineTo(x - 25, y + factor * spacing + offset);
                    ctx.stroke();
                } else if (direction === 'left') {
                    ctx.beginPath();
                    ctx.moveTo(x + 14, y + factor * spacing + offset);
                    ctx.lineTo(x + 25, y + factor * spacing + offset);
                    ctx.stroke();
                } else if (direction === 'up') {
                    ctx.beginPath();
                    ctx.moveTo(x + factor * spacing + offset, y + 14);
                    ctx.lineTo(x + factor * spacing + offset, y + 25);
                    ctx.stroke();
                } else if (direction === 'down') {
                    ctx.beginPath();
                    ctx.moveTo(x + factor * spacing + offset, y - 14);
                    ctx.lineTo(x + factor * spacing + offset, y - 25);
                    ctx.stroke();
                }
            }
            ctx.globalAlpha = 1;
            ctx.restore();
        }
        function drawPuffyHead(ctx, x, y) {
            ctx.save();
            ctx.shadowColor = "#fb7185";
            ctx.shadowBlur = 20;
            ctx.fillStyle = "#f59e42";
            ctx.beginPath();
            ctx.arc(x, y, gridSize * 0.87 + Math.sin(animTick * 0.20) * 2, 0, Math.PI * 2);
            ctx.closePath();
            ctx.fill();
            ctx.restore();
        }
        function drawBrakeWave(ctx, x, y, tick) {
            ctx.save();
            let baseR = gridSize * 1.1;
            for (let i = 0; i < 3; i++) {
                ctx.beginPath();
                ctx.globalAlpha = 0.21 - i * 0.05;
                ctx.strokeStyle = "#fb7185";
                ctx.lineWidth = 3 - i;
                let waveRadius = baseR + Math.abs(Math.sin(tick * 0.23 + i)) * (10 + i * 5);
                ctx.arc(x, y, waveRadius, 0, Math.PI * 2);
                ctx.stroke();
            }
            ctx.globalAlpha = 1;
            ctx.restore();
        }
        function updateSpeedBar(animState, currentSpeed, normalSpeed, minSpeed, maxSlowSpeed) {
            let val = 0;
            if (currentSpeed > normalSpeed) {
                val = -Math.min((currentSpeed - normalSpeed) / (maxSlowSpeed - normalSpeed), 1);
            } else if (currentSpeed < normalSpeed) {
                val = Math.min((normalSpeed - currentSpeed) / (normalSpeed - minSpeed), 1);
            }
            let bar = speedBar;
            let barIndicator = speedBarIndicator;
            let px = ((val + 1) / 2) * bar.offsetWidth;
            let width = bar.offsetWidth * 0.09 + Math.abs(val) * bar.offsetWidth * 0.4;
            px = Math.max(2, Math.min(bar.offsetWidth - width - 2, px - width / 2));
            let bg = "#93c5fd";
            if (animState === "accelerating") bg = "linear-gradient(90deg,#38bdf8 40%,#06b6d4 100%)";
            if (animState === "braking") bg = "linear-gradient(90deg,#fb7185 10%,#f43f5e 80%)";
            barIndicator.style.left = px + "px";
            barIndicator.style.width = width + "px";
            barIndicator.style.height = "100%";
            barIndicator.style.background = bg;
            barIndicator.style.boxShadow = (animState !== "normal")
                ? `0 0 16px 3px ${animState === "accelerating" ? "#06b6d4" : "#f43f5e"}99`
                : "none";
        }
        function getNewFoodPosition() {
            let pos;
            while (true) {
                pos = {
                    x: Math.floor(Math.random() * tileCount),
                    y: Math.floor(Math.random() * tileCount)
                };
                if (!snake.some(segment => segment.x === pos.x && segment.y === pos.y)) {
                    return pos;
                }
            }
        }
        function gameOver() {
            clearTimeout(animationFrameId);
            setTimeout(() => {
                alert(`Game Over! Your score: ${score}`);
                resetGameVars();
                draw();
            }, 200);
        }
        function roundedRect(ctx, x, y, w, h, r) {
            ctx.beginPath();
            ctx.moveTo(x + r, y);
            ctx.lineTo(x + w - r, y);
            ctx.quadraticCurveTo(x + w, y, x + w, y + r);
            ctx.lineTo(x + w, y + h - r);
            ctx.quadraticCurveTo(x + w, y + h, x + w - r, y + h);
            ctx.lineTo(x + r, y + h);
            ctx.quadraticCurveTo(x, y + h, x, y + h - r);
            ctx.lineTo(x, y + r);
            ctx.quadraticCurveTo(x, y, x + r, y);
            ctx.closePath();
        }
        // Service Worker registration for PWA
        if ('serviceWorker' in navigator) {
            window.addEventListener('load', function () {
                navigator.serviceWorker.register('./service-worker.js');
            });
        }
        // --- Responsive Canvas Sizing ---
        function fitCanvas() {
            let size = Math.min(window.innerWidth * 0.96, window.innerHeight * 0.7, 400);
            canvas.style.width = size + "px";
            canvas.style.height = size + "px";
            adjustGridForScreen();
        }
        window.addEventListener("resize", fitCanvas);
        fitCanvas();
    </script>
</body>

</html>